{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///waveshaper-dom.min.js","webpack:///webpack/bootstrap d48635f3e273659c408a","webpack:///./node_modules/waveshaper/dist/waveshaper.js","webpack:///external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammerjs\",\"umd\":\"hammerjs\"}","webpack:///./src/index.ts","webpack:///./src/core/domrender-waveshaper.ts","webpack:///./src/config/hammerconfig.ts","webpack:///./src/interactions/cut.ts","webpack:///./src/interactions/drag.ts","webpack:///./src/interactions/pan.ts","webpack:///./src/interactions/zoom.ts","webpack:///./src/interactions/resize.ts","webpack:///./src/render/line.ts","webpack:///./src/interactions/enter.ts","webpack:///./src/config/dom-config.ts","webpack:///./src/models/dragstate.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","peak_1","rms_1","flatten_1","Track","id","intervals","_flattened","default","slice","flatten","getDuration","Math","max","apply","map","end","calculate","options","dataMap","meterType","flattened","sampleSize","ceil","samplesPerPixel","resolution","start","scrollPosition","startSecond","samplerate","secondsPerPixel","endSecond","width","peaks","Float32Array","currentIntervalIndex","findIndex","offsetStart","maxIntervalIncrementIndex","length","currentInterval","buffer","source","currentSecond","startBorder","endBorder","intervalBorder","secondsIntoInterval","startSample","floor","endSample","length_1","loopEnd","min","j","sample","set","posSum","negSum","count","val","sqrt","__assign","assign","t","arguments","segment","segments","sorted","sort","normalized","normalizeIndex","copied","copy","grouped","groupByIndex","weightedMerge","index","preNormalizeIndex","Number","MIN_SAFE_INTEGER","forEach","el","a","b","cmp","reduce","groups","interval","push","_i","_a","keys","merged","merge","combine","result","current","next","highIndexes","lowIndexes","highIndex","lowIndex","high","low","defaultOptions","waveshaper_1","WaveShaper","track_1","managerconfig_1","defaultConfig","rms","peak","tracks","Map","audioData","callbackMap","_activeWaveShapers","optionsValid","Error","JSON","stringify","_options","_lastProcessResult","_duration","timeToPosition","time","positionToTime","position","_this","ids","getProcessIds","waveShaper","getTrack","process","toProcess","data","wave","invokeCallbacks","on","callBack","callbackArray","off","indexOf","splice","setOptions","invokeOptionsCallbacks","setTracks","track","foundWave","setData","setActive","clearTracks","removeCallbacksById","delete","undefined","trackResult","callbacks","callback","cb","Array","from","values","maxDuration","duration","domrender_waveshaper_1","DomRenderWaveShaper","__extends","extendStatics","setPrototypeOf","__proto__","__","constructor","create","Hammer","hammerconfig_1","cut_1","drag_1","pan_1","zoom_1","resize_1","line_1","enter_1","dom_config_1","dragstate_1","_super","unregister","unregisterMap","canvasMap","_hammer","input","registerCanvas","canvas","color","ctx","getContext","classList","add","setAttribute","style","height","scale","devicePixelRatio","unregisterCanvas","dragState","registerSetsActive","activeWaveShapers","concat","unregisterEvents","loadData","dat","fetch","url","then","res","arrayBuffer","decodeAudioData","audioBuffer","getChannelData","catch","e","console","log","setInteraction","element","hammer","destroy","clearInteraction","hammerOptions","touchAction","recognizers","Pan","direction","DIRECTION_HORIZONTAL","Pinch","enable","Tap","manager","shouldHandle","target","mode","hasAttribute","ev","getEventTarget","srcEvent","getAttribute","bb","getBoundingClientRect","center","x","left","find","newSegment","generateId","PointerEvent","setPointerCapture","pointerId","activeSegment","activeSegmentStart","dragWave","dragging","change","deltaX","newTime","default_1","panState","panMax","scrollWidth","endMargin","panStart","newPosition","zoomState","sppStart","maxWidth","sampleAtLeft","samplesInView","samplesToCenter","newSpp","newSamplesInView","newSamplesToCenter","newScroll","resizeState","activeSegmentSide","activeSegmentOffsetStart","activeSegmentOffsetEnd","active","waveform","fillStyle","clearRect","inSegment","segmentStart","pointInSegment","fillRect","beginPath","moveTo","lineTo","round","closePath","rect","fill","enterlistener","pointerEnter","addEventListener","document","elementFromPoint","clientX","clientY","HTMLCanvasElement","currentId","removeEventListener","defaultDomOptions","random","toString"],"mappings":"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","file":"waveshaper-dom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hammerjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hammerjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WS\"] = factory(require(\"hammerjs\"));\n\telse\n\t\troot[\"WS\"] = factory(root[\"Hammer\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hammerjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hammerjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WS\"] = factory(require(\"hammerjs\"));\n\telse\n\t\troot[\"WS\"] = factory(root[\"Hammer\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waveshaper\"] = factory();\n\telse\n\t\troot[\"waveshaper\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar peak_1 = __webpack_require__(1);\r\nvar rms_1 = __webpack_require__(2);\r\nvar flatten_1 = __webpack_require__(3);\r\nvar Track = /** @class */ (function () {\r\n    function Track(id, intervals) {\r\n        this.id = id;\r\n        this.intervals = intervals || [];\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    }\r\n    Object.defineProperty(Track.prototype, \"flattened\", {\r\n        get: function () { return this._flattened.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Track.prototype.flatten = function () {\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    };\r\n    /**\r\n     * Gets the duration of the audio in seconds\r\n     *\r\n     * @returns Decimal value of total duration in seconds\r\n     */\r\n    Track.prototype.getDuration = function () {\r\n        return Math.max.apply(Math, this.intervals.map(function (s) { return s.end; }));\r\n    };\r\n    /**\r\n     * Gets the summerized values for the current settings\r\n     *\r\n     * @param options\r\n     * @param dataMap\r\n     * @returns Two dimensional array, one entry for each pixel, for each pixel a min\r\n     * and a max value.\r\n     */\r\n    Track.prototype.calculate = function (options, dataMap) {\r\n        switch (options.meterType) {\r\n            case 'peak':\r\n                return peak_1.default(options, this.flattened, dataMap);\r\n            default:\r\n                return rms_1.default(options, this.flattened, dataMap);\r\n        }\r\n    };\r\n    return Track;\r\n}());\r\nexports.default = Track;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates peak values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var min = 0, max = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize) {\r\n            var sample = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (sample > max)\r\n                max = sample;\r\n            else if (sample < min)\r\n                min = sample;\r\n        }\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculate rms values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var posSum = 0, negSum = 0, count = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize, count++) {\r\n            var val = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (val > 0) {\r\n                posSum += val * val;\r\n            }\r\n            else {\r\n                negSum += val * val;\r\n            }\r\n        }\r\n        var min = -Math.sqrt(negSum / count);\r\n        var max = Math.sqrt(posSum / count);\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar start = function (segment) { return segment.start + segment.offsetStart; };\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param segments Segments to flatten\r\n * @returns flattened Interval array\r\n */\r\nexports.default = (function (segments) {\r\n    if (segments == null || segments.length === 0)\r\n        return [];\r\n    var sorted = sort(segments);\r\n    var normalized = normalizeIndex(sorted);\r\n    var copied = copy(normalized);\r\n    var grouped = groupByIndex(copied);\r\n    return weightedMerge(grouped);\r\n});\r\n/**\r\n * Copies elements so original are unaltered\r\n *\r\n * @param intervals\r\n */\r\nvar copy = function (intervals) { return intervals.map(function (i) { return (__assign({}, i)); }); };\r\n/**\r\n * When an element is altered the index is set very high,\r\n * this functions normalizes to indexes back to 0\r\n *\r\n * @param segments\r\n */\r\nvar normalizeIndex = function (segments) {\r\n    var index = 0;\r\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\r\n    segments.forEach(function (el) {\r\n        if (el.index > preNormalizeIndex) {\r\n            preNormalizeIndex = el.index;\r\n            el.index = ++index;\r\n        }\r\n        else {\r\n            el.index = index;\r\n        }\r\n    });\r\n    return segments;\r\n};\r\n/**\r\n * Sorts the intervals by index, then by start\r\n *\r\n * @param intervals\r\n * @return Interval array\r\n */\r\nvar sort = function (intervals) {\r\n    return intervals.sort(function (a, b) { return cmp(a.index, b.index) || cmp(start(a), start(b)); });\r\n};\r\n/**\r\n * Returns a map of intervals grouped by the key property\r\n *\r\n * @param intervals\r\n * @param key\r\n *\r\n * @returns Map of index => interval[]\r\n */\r\nvar groupByIndex = function (intervals) {\r\n    return intervals.reduce(function (groups, interval) {\r\n        (groups[interval.index] = groups[interval.index] || []).push(interval);\r\n        return groups;\r\n    }, {});\r\n};\r\n/**\r\n * Merges all the groups by index\r\n *\r\n * @param grouped\r\n * @returns Interval array\r\n */\r\nvar weightedMerge = function (grouped) {\r\n    var flattened = null;\r\n    for (var _i = 0, _a = Object.keys(grouped); _i < _a.length; _i++) {\r\n        var index = _a[_i];\r\n        var merged = merge(grouped[index]);\r\n        if (flattened == null) {\r\n            flattened = merged;\r\n        }\r\n        else {\r\n            flattened = combine(merged, flattened);\r\n        }\r\n    }\r\n    return flattened;\r\n};\r\n/**\r\n * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n *\r\n * @param intervals\r\n * @returns Interval array\r\n */\r\nvar merge = function (intervals) {\r\n    if (intervals.length <= 1)\r\n        return intervals;\r\n    var result = [];\r\n    var current = intervals[0];\r\n    for (var i = 1; i < intervals.length; i++) {\r\n        var next = intervals[i];\r\n        // If current is completely overlapped by second it is merged into it\r\n        if (current.end >= next.end) {\r\n            continue;\r\n            // Resolves partial overlaps by setting end of current to start of next\r\n        }\r\n        else if (start(next) < current.end) {\r\n            result.push(__assign({}, current, { end: start(next) }));\r\n            current = next;\r\n        }\r\n        else {\r\n            // No overlap, push onto results\r\n            result.push(current);\r\n            current = next;\r\n        }\r\n    }\r\n    result.push(current);\r\n    return result;\r\n};\r\n/**\r\n * Given two sets of intervals it merges them so the highIndexes set has priority\r\n *\r\n * @param highIndexes\r\n * @param lowIndexes\r\n *\r\n * @returns Interval array\r\n */\r\nvar combine = function (highIndexes, lowIndexes) {\r\n    var highIndex = 0;\r\n    var lowIndex = 0;\r\n    var merged = [];\r\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\r\n        var high = highIndexes[highIndex];\r\n        var low = lowIndexes[lowIndex];\r\n        // Only low priority left so push low onto results\r\n        if (highIndex === highIndexes.length) {\r\n            merged.push(__assign({}, low));\r\n            lowIndex++;\r\n            // Only high priority left so push high onto results\r\n        }\r\n        else if (lowIndex === lowIndexes.length) {\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // High priority start before or at same time as low\r\n        }\r\n        else if (start(high) <= start(low)) {\r\n            // No overlap between low and high\r\n            // low:                 ----------------------\r\n            // high: ---------------\r\n            if (high.end <= start(low)) {\r\n                // Partial overlap where high ends after low\r\n                // low:                 ----------------------\r\n                // high: ----------------------\r\n            }\r\n            else if (high.end < low.end) {\r\n                low.offsetStart = high.end - low.start;\r\n                // Low index completely overlapped, dismiss it\r\n                // low:               -----------\r\n                // high: -------------------------------------\r\n            }\r\n            else {\r\n                lowIndex++;\r\n            }\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // Low priority starts before high\r\n        }\r\n        else {\r\n            // No overlap between low and high intervals\r\n            // low: ---------------\r\n            // high                ----------------------\r\n            if (low.end <= start(high)) {\r\n                merged.push(__assign({}, low));\r\n                lowIndex++;\r\n                // Partial overlap where high ends after low\r\n                // low: ---------------------\r\n                // high                ----------------------\r\n            }\r\n            else if (high.end > low.end) {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                lowIndex++;\r\n                // Partial overlap where high ends before low\r\n                // low: -------------------------------------\r\n                // high             -----------\r\n            }\r\n            else {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                low.offsetStart = high.end - low.start;\r\n            }\r\n        }\r\n    }\r\n    return merged;\r\n};\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nvar cmp = function (a, b) {\r\n    if (a > b)\r\n        return +1;\r\n    if (a < b)\r\n        return -1;\r\n    return 0;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 10,\r\n    meterType: 'rms',\r\n    width: 300,\r\n    samplerate: 44100\r\n};\r\nexports.default = defaultOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(6);\r\nexports.WaveShaper = waveshaper_1.default;\r\nvar track_1 = __webpack_require__(0);\r\nexports.Track = track_1.default;\r\nvar managerconfig_1 = __webpack_require__(4);\r\nexports.defaultConfig = managerconfig_1.default;\r\nvar rms_1 = __webpack_require__(2);\r\nexports.rms = rms_1.default;\r\nvar peak_1 = __webpack_require__(1);\r\nexports.peak = peak_1.default;\r\nvar flatten_1 = __webpack_require__(3);\r\nexports.flatten = flatten_1.default;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar track_1 = __webpack_require__(0);\r\nvar managerconfig_1 = __webpack_require__(4);\r\n/**\r\n *\r\n *\r\n * @export\r\n */\r\nvar WaveShaper = /** @class */ (function () {\r\n    /**\r\n     * @param [options=defaultOptions] Initial options\r\n     * @throws Throws an error if samplerate is null or NaN\r\n     */\r\n    function WaveShaper(options) {\r\n        if (options === void 0) { options = managerconfig_1.default; }\r\n        /**\r\n         * Map of waveshapers managed by the manager\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.tracks = new Map();\r\n        /**\r\n         * Map of audio data\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.audioData = new Map();\r\n        /**\r\n         * @description Map of callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.callbackMap = new Map();\r\n        this._activeWaveShapers = [];\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, managerconfig_1.default, options);\r\n    }\r\n    Object.defineProperty(WaveShaper.prototype, \"options\", {\r\n        /**\r\n         * @description Currect settings\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"activeWaveShapers\", {\r\n        /**\r\n         * @description Active id's, redraws when draw is called without argument\r\n         *\r\n         * @readonly\r\n         * @unused\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._activeWaveShapers.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"lastProcessResult\", {\r\n        /**\r\n         * @description Last result of calling process, argument given to all callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._lastProcessResult; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"duration\", {\r\n        /**\r\n         * @description Total duration of all tracks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._duration; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gives the position corresponding to a given time\r\n     *\r\n     * @param time\r\n     */\r\n    WaveShaper.prototype.timeToPosition = function (time) {\r\n        return (time * this._options.samplerate) / this._options.samplesPerPixel;\r\n    };\r\n    /**\r\n     * Gives the time corresponding to a given position\r\n     * @param position\r\n     */\r\n    WaveShaper.prototype.positionToTime = function (position) {\r\n        return (position * this._options.samplesPerPixel) / this._options.samplerate;\r\n    };\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     *\r\n     * @param id\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.flatten = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.getProcessIds.apply(this, ids).forEach(function (id) {\r\n            var waveShaper = _this.getTrack(id);\r\n            if (waveShaper != null)\r\n                waveShaper.flatten();\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Processes all relevant WaveShapers and invokes registered callbacks\r\n     *\r\n     * @param ids Options array of id's to draw\r\n     * @param forceDraw Force redraw of the given waves\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.process = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        var toProcess = this.getProcessIds.apply(this, ids);\r\n        var options = __assign({}, this.options);\r\n        var data = [];\r\n        for (var i = 0; i < toProcess.length; i++) {\r\n            var id = toProcess[i];\r\n            var wave = this.getTrack(id);\r\n            if (wave == null)\r\n                continue;\r\n            var peaks = wave.calculate(options, this.audioData);\r\n            data.push({ id: id, data: peaks });\r\n        }\r\n        // Invoke callbacks after returning value.\r\n        this._lastProcessResult = { options: options, data: data };\r\n        this.invokeCallbacks(this._lastProcessResult);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a callback that fires when the track with given id is processed\r\n     *\r\n     * @param id id of Track to register to\r\n     * @param callBack will be invoked when the given track is processed\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.on = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null) {\r\n            this.callbackMap.set(id, [callBack]);\r\n        }\r\n        else {\r\n            callbackArray.push(callBack);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters a callback from the given track, will no longer be called\r\n     *\r\n     * @param id id of Track to unregister from\r\n     * @param callBack callback to remove\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.off = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return this;\r\n        var index = callbackArray.indexOf(callBack);\r\n        if (index < 0)\r\n            return this;\r\n        callbackArray = callbackArray.splice(index, 1);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Merges the given options into the current and returns updated options\r\n     *\r\n     * @param options A (partial) ManagerOptions object\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setOptions = function (options) {\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, this.options, options);\r\n        this.invokeOptionsCallbacks(this.options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     *\r\n     * @param id id of WaveShaper\r\n     * @param segments Segments in wave\r\n     * @param color Background color of segments\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setTracks = function () {\r\n        var tracks = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tracks[_i] = arguments[_i];\r\n        }\r\n        for (var i = 0; i < tracks.length; i++) {\r\n            var track = tracks[i];\r\n            var foundWave = this.getTrack(track.id);\r\n            if (foundWave == null) {\r\n                var wave = new track_1.default(track.id, track.intervals);\r\n                this.tracks.set(track.id, wave);\r\n            }\r\n            else {\r\n                foundWave.intervals = track.intervals || [];\r\n                foundWave.flatten();\r\n            }\r\n        }\r\n        this._duration = this.getDuration();\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds audio data to the waveshaper and redraws waveshapers using it\r\n     *\r\n     * @param id  Data id, refered to by source parameter of segments\r\n     * @param data AudioBuffer with audio data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setData = function () {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            data[_i] = arguments[_i];\r\n        }\r\n        data.forEach(function (d) {\r\n            _this.audioData.set(d.id, d.data);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description The given id's are set as the active waveshapers, process only processes these when set,\r\n     * call with no values to allways process all values (default)\r\n     *\r\n     * @param ids Waveshaper id's to set as active\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setActive = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this._activeWaveShapers = ids;\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Removes the waves and all callbacks with given id from the manager\r\n     *\r\n     * @param id\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.clearTracks = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        ids.forEach(function (id) {\r\n            _this.removeCallbacksById(id);\r\n            _this.tracks.delete(id);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Gets Track with given id\r\n     *\r\n     * @param id\r\n     * @returns Track with given ID\r\n     */\r\n    WaveShaper.prototype.getTrack = function (id) {\r\n        return this.tracks.get(id);\r\n    };\r\n    /**\r\n     * Validates given options\r\n     *\r\n     * @param options\r\n     * @returns true if valid, false if not\r\n     */\r\n    WaveShaper.prototype.optionsValid = function (options) {\r\n        return (options.samplesPerPixel === undefined || options.samplesPerPixel > 0) &&\r\n            (options.meterType === undefined || options.meterType) &&\r\n            (options.resolution === undefined || options.resolution > 0) &&\r\n            (options.width === undefined || options.width > 0) &&\r\n            (options.scrollPosition === undefined || options.scrollPosition >= 0) &&\r\n            (options.samplerate === undefined || options.samplerate > 0);\r\n    };\r\n    /**\r\n     * Invokes all registered callbacks registered to a waveshaper id in the data list\r\n     *\r\n     * @param options\r\n     * @param data\r\n     */\r\n    WaveShaper.prototype.invokeCallbacks = function (result) {\r\n        for (var i = 0; i < result.data.length; i++) {\r\n            var trackResult = result.data[i];\r\n            var callbacks = this.callbackMap.get(trackResult.id);\r\n            if (callbacks == null)\r\n                continue;\r\n            for (var j = 0; j < callbacks.length; j++) {\r\n                var callback = callbacks[j];\r\n                callback(result.options, new Float32Array(trackResult.data));\r\n            }\r\n        }\r\n    };\r\n    WaveShaper.prototype.invokeOptionsCallbacks = function (options) {\r\n        var callbacks = this.callbackMap.get('options');\r\n        if (callbacks == null)\r\n            return;\r\n        callbacks.forEach(function (cb) { return cb(options, null); });\r\n    };\r\n    WaveShaper.prototype.getProcessIds = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        if (ids.length > 0)\r\n            return ids;\r\n        if (this._activeWaveShapers.length > 0)\r\n            return this._activeWaveShapers;\r\n        return Array.from(this.tracks.keys());\r\n    };\r\n    WaveShaper.prototype.removeCallbacksById = function (id) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return;\r\n        callbackArray.splice(0, callbackArray.length);\r\n        this.callbackMap.delete(id);\r\n    };\r\n    /**\r\n     * @description Returns the maximum duration of all the waveshapers managed by this class\r\n     *\r\n     * @returns Maximum duration in seconds\r\n     * @memberof WaveShaper\r\n     */\r\n    WaveShaper.prototype.getDuration = function () {\r\n        return Array.from(this.tracks.values()).reduce(function (maxDuration, waveShaper) {\r\n            var duration = waveShaper.getDuration();\r\n            return duration > maxDuration ? duration : maxDuration;\r\n        }, 0);\r\n    };\r\n    return WaveShaper;\r\n}());\r\nexports.default = WaveShaper;\r\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=waveshaper.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar domrender_waveshaper_1 = __webpack_require__(3);\r\nexports.DomRenderWaveShaper = domrender_waveshaper_1.default;\r\nexports.default = new domrender_waveshaper_1.default();\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(0);\r\nvar Hammer = __webpack_require__(1);\r\nvar hammerconfig_1 = __webpack_require__(4);\r\nvar cut_1 = __webpack_require__(5);\r\nvar drag_1 = __webpack_require__(6);\r\nvar pan_1 = __webpack_require__(7);\r\nvar zoom_1 = __webpack_require__(8);\r\nvar resize_1 = __webpack_require__(9);\r\nvar line_1 = __webpack_require__(10);\r\nvar enter_1 = __webpack_require__(11);\r\nvar dom_config_1 = __webpack_require__(12);\r\nvar dragstate_1 = __webpack_require__(13);\r\n/**\r\n * Extends WaveShapeManager to allow for easy canvas rendering registration.\r\n *\r\n * @inheritDoc\r\n */\r\nvar DomRenderWaveShaper = /** @class */ (function (_super) {\r\n    __extends(DomRenderWaveShaper, _super);\r\n    function DomRenderWaveShaper(options) {\r\n        if (options === void 0) { options = dom_config_1.default; }\r\n        var _this = _super.call(this, options) || this;\r\n        _this.unregister = function () { };\r\n        _this.unregisterMap = new Map();\r\n        _this.canvasMap = new Map();\r\n        _this._options = __assign({}, dom_config_1.default, _this._options);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"scrollWidth\", {\r\n        get: function () { return (this._duration * this._options.samplerate) / this._options.samplesPerPixel; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"options\", {\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"hammer\", {\r\n        get: function () { return this._hammer; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DomRenderWaveShaper.prototype.setOptions = function (input) {\r\n        this._options = __assign({}, this._options, input);\r\n        this.invokeOptionsCallbacks(this.options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description When a canvas is registered through this method each time the\r\n     * waveform is updated the canvas will be rerendered.\r\n     *\r\n     * It returns an unregister method, call to stop receiving callbacks.\r\n     *\r\n     * @param id WaveShaper id to register to.\r\n     * @param canvas Canvas to render to\r\n     * @param color Background color of segments\r\n     */\r\n    DomRenderWaveShaper.prototype.registerCanvas = function (id, canvas, color) {\r\n        var _this = this;\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx == null)\r\n            throw Error('Cannot get context from canvas.');\r\n        // Add classes and data attributes\r\n        canvas.classList.add('waveshaper');\r\n        canvas.setAttribute('data-wave-id', id);\r\n        canvas.style.width = this.options.width + 'px';\r\n        canvas.style.height = this.options.height + 'px';\r\n        var scale = (devicePixelRatio || 1) < 1 ? 1 : (devicePixelRatio || 1);\r\n        canvas.width = this.options.width * scale;\r\n        canvas.height = this.options.height;\r\n        ctx.scale(scale, 1);\r\n        var callBack = function (options, data) { return line_1.default(data, options, ctx, color); };\r\n        this.on(id, callBack);\r\n        this.unregisterCanvas(id);\r\n        this.canvasMap.set(id, function () { return _this.off(id, callBack); });\r\n        var unregister = enter_1.default(this, canvas, dragstate_1.dragState);\r\n        this.unregisterMap.set(id, unregister);\r\n        // If registerSetsActive is true \r\n        if (this._options.registerSetsActive) {\r\n            this.setActive.apply(this, this.activeWaveShapers.concat(id));\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Clears the callbacks associated with this canvas\r\n     *\r\n     * @param id\r\n     * @returns Instance of WaveShaper\r\n     */\r\n    DomRenderWaveShaper.prototype.unregisterCanvas = function (id) {\r\n        var unregister = this.canvasMap.get(id);\r\n        if (unregister != null) {\r\n            unregister();\r\n            this.canvasMap.delete(id);\r\n        }\r\n        var unregisterEvents = this.unregisterMap.get(id);\r\n        if (unregisterEvents != null) {\r\n            unregisterEvents();\r\n            this.unregisterMap.delete(id);\r\n        }\r\n        if (this._options.registerSetsActive) {\r\n            var index = this.activeWaveShapers.indexOf(id);\r\n            if (index != -1)\r\n                this.setActive.apply(this, this.activeWaveShapers.splice(index, 1));\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Loads and saves a set of url's to audio files.\r\n     *\r\n     * @param ctx\r\n     * @param data\r\n     */\r\n    DomRenderWaveShaper.prototype.loadData = function (ctx) {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            data[_i - 1] = arguments[_i];\r\n        }\r\n        data.forEach(function (dat) {\r\n            fetch(dat.url)\r\n                .then(function (res) { return res.arrayBuffer(); })\r\n                .then(function (arrayBuffer) { return ctx.decodeAudioData(arrayBuffer); })\r\n                .then(function (audioBuffer) {\r\n                _this.setData({ id: dat.id, data: audioBuffer.getChannelData(0) }).process();\r\n            })\r\n                .catch(function (e) { return console.log(e); });\r\n        });\r\n        return this;\r\n    };\r\n    DomRenderWaveShaper.prototype.setInteraction = function (element) {\r\n        if (element == null)\r\n            throw Error('Interaction container element could not be found.');\r\n        this.unregister();\r\n        element.setAttribute('touch-action', 'none');\r\n        var hammer = new Hammer(element, hammerconfig_1.default);\r\n        this._hammer = hammer;\r\n        drag_1.default(this, hammer, dragstate_1.dragState);\r\n        cut_1.default(this, hammer);\r\n        pan_1.default(this, hammer);\r\n        zoom_1.default(this, hammer);\r\n        resize_1.default(this, hammer);\r\n        this.unregister = function () {\r\n            hammer.destroy();\r\n        };\r\n        return this;\r\n    };\r\n    DomRenderWaveShaper.prototype.clearInteraction = function () {\r\n        this.unregister();\r\n        this.unregister = function () { };\r\n        this._hammer = null;\r\n    };\r\n    return DomRenderWaveShaper;\r\n}(waveshaper_1.WaveShaper));\r\nexports.default = DomRenderWaveShaper;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Hammer = __webpack_require__(1);\r\nvar hammerOptions = {\r\n    touchAction: 'pan-y',\r\n    recognizers: [\r\n        [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }],\r\n        [Hammer.Pinch, { enable: true }],\r\n        [Hammer.Tap]\r\n    ]\r\n};\r\nexports.default = hammerOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nexports.default = (function (manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'cut' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('tap', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (options == null || !shouldHandle(target, options))\r\n            return;\r\n        // Allready checked for null\r\n        var id = target.getAttribute('data-wave-id');\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = target.getBoundingClientRect();\r\n        var time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        var newSegment = __assign({}, segment, { offsetStart: time - segment.start, id: options.generateId() });\r\n        segment.end = time;\r\n        wave.intervals.push(newSegment);\r\n        manager.flatten(wave.id);\r\n        manager.process(wave.id);\r\n    });\r\n});\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager Waveshape Manager\r\n * @param hammer Hammer instance\r\n * @param container Container element\r\n */\r\nexports.default = (function (manager, hammer, dragState) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'drag' && target.hasAttribute('data-wave-id'); };\r\n    /**\r\n     * Sets up the drag by finding the\r\n     */\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        // Allready checked for existance\r\n        var id = target.getAttribute('data-wave-id');\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = target.getBoundingClientRect();\r\n        var time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        if (ev.srcEvent instanceof PointerEvent) {\r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n        dragState.options = options;\r\n        dragState.activeSegment = segment;\r\n        dragState.activeSegmentStart = dragState.activeSegment.start;\r\n        dragState.duration = segment.end - segment.start;\r\n        dragState.activeSegment.index = 1000;\r\n        dragState.dragWave = wave;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || dragState.activeSegment == null || dragState.dragWave == null\r\n            || dragState.dragging || !shouldHandle(target, dragState.options))\r\n            return;\r\n        dragState.dragging = true;\r\n        /**\r\n         * TODO below implementation stops all updates on touch devices on new track (tested on Samsung Galaxy s8),\r\n         * when dragged back to original keeps working. Works on desktop, it's a small performance improvement as\r\n         * it prevents a single track flatten + process when transferring a segment between tracks.\r\n         */\r\n        //// If the target has moved it is handled by the mouseHover function\r\n        // const id = ev.target.getAttribute('data-wave-id');\r\n        // if(id !== dragState.dragWave.id)\r\n        //     return;\r\n        var change = (ev.deltaX * dragState.options.samplesPerPixel) / dragState.options.samplerate;\r\n        var newTime = dragState.activeSegmentStart + change;\r\n        if (newTime + dragState.activeSegment.offsetStart < 0) {\r\n            newTime = -dragState.activeSegment.offsetStart;\r\n        }\r\n        dragState.activeSegment.start = newTime;\r\n        dragState.activeSegment.end = newTime + dragState.duration;\r\n        manager.flatten(dragState.dragWave.id);\r\n        manager.process(dragState.dragWave.id);\r\n        dragState.dragging = false;\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n        dragState.activeSegment = null;\r\n        dragState.activeSegmentStart = 0;\r\n        dragState.dragWave = null;\r\n        dragState.options = null;\r\n        dragState.duration = 0;\r\n    });\r\n});\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar endMargin = 500;\r\nvar panState = {\r\n    panStart: 0,\r\n    panMax: 0,\r\n    options: null\r\n};\r\n/**\r\n * Adds pan functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'pan' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        if (ev.srcEvent instanceof PointerEvent) {\r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n        panState.panMax = manager.scrollWidth + endMargin;\r\n        panState.panStart = options.scrollPosition;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        panState.options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, panState.options))\r\n            return;\r\n        var position = panState.panStart - ev.deltaX;\r\n        var newPosition = position > 0 ? position : 0;\r\n        // If it was and is still 0 no need to update\r\n        if (newPosition === panState.options.scrollPosition)\r\n            return;\r\n        if (newPosition > panState.panMax - panState.options.width)\r\n            return;\r\n        manager.setOptions({ scrollPosition: newPosition }).process();\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (panState.options == null || !shouldHandle(target, panState.options))\r\n            return;\r\n        panState.options = null;\r\n        panState.panStart = 0;\r\n        panState.panMax = 0;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar endMargin = 500;\r\nvar zoomState = {\r\n    maxWidth: 0,\r\n    sppStart: 0,\r\n    options: null\r\n};\r\n/**\r\n * Adds pinch zoom functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'pan' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('pinchstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        if (ev.srcEvent instanceof PointerEvent) {\r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n        zoomState.sppStart = options.samplesPerPixel;\r\n        zoomState.maxWidth = manager.scrollWidth + endMargin;\r\n    });\r\n    hammer.on('pinchmove', function (ev) {\r\n        zoomState.options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n        var sampleAtLeft = zoomState.options.scrollPosition * zoomState.options.samplesPerPixel;\r\n        var samplesInView = zoomState.options.width * zoomState.options.samplesPerPixel;\r\n        var samplesToCenter = samplesInView / 2;\r\n        var newSpp = zoomState.sppStart * ev.scale;\r\n        var newSamplesInView = zoomState.options.width * newSpp;\r\n        var newSamplesToCenter = newSamplesInView / 2;\r\n        var maxWidth = manager.scrollWidth + endMargin;\r\n        var maxSamplesInView = maxWidth * zoomState.options.samplerate;\r\n        if (newSamplesInView >= maxSamplesInView)\r\n            return;\r\n        var newScroll = (sampleAtLeft + samplesToCenter - newSamplesToCenter) / newSpp;\r\n        manager.setOptions({\r\n            samplesPerPixel: newSpp,\r\n            scrollPosition: newScroll >= 0 ? newScroll : 0\r\n        }).process();\r\n    });\r\n    hammer.on('pinchend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n        zoomState.sppStart = 0;\r\n        zoomState.maxWidth = 0;\r\n        zoomState.options = null;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar resizeState = {\r\n    activeSegment: null,\r\n    activeSegmentSide: null,\r\n    activeSegmentOffsetStart: 0,\r\n    activeSegmentOffsetEnd: 0,\r\n    dragWave: null,\r\n    options: null\r\n};\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'resize' && target != null && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        // Already checked that it exists\r\n        var id = target.getAttribute('data-wave-id');\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = target.getBoundingClientRect();\r\n        var time = ((options.scrollPosition + (ev.center.x - bb.left)) * options.samplesPerPixel) / options.samplerate;\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        resizeState.activeSegmentSide =\r\n            time < interval.start + interval.offsetStart + ((interval.end - (interval.start + interval.offsetStart)) / 2) ?\r\n                'left' :\r\n                'right';\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        if (ev.srcEvent instanceof PointerEvent) {\r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n        resizeState.options = options;\r\n        resizeState.activeSegment = segment;\r\n        resizeState.activeSegmentOffsetStart = segment.offsetStart;\r\n        resizeState.activeSegmentOffsetEnd = segment.end;\r\n        segment.index = 1000;\r\n        resizeState.dragWave = wave;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (resizeState.dragWave == null || resizeState.activeSegment == null || resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n        var options = manager.options;\r\n        var change = (ev.deltaX * options.samplesPerPixel) / options.samplerate;\r\n        var newTime = resizeState.activeSegmentSide === 'left' ?\r\n            resizeState.activeSegmentOffsetStart + change :\r\n            resizeState.activeSegmentOffsetEnd + change;\r\n        // Don't allow offset to become less than 0\r\n        if (newTime < 0) {\r\n            newTime = 0;\r\n        }\r\n        var active = resizeState.activeSegment;\r\n        var newDuration = resizeState.activeSegmentSide === 'left' ?\r\n            active.end - active.start - newTime :\r\n            newTime - active.start - active.offsetStart;\r\n        // Do not allow resizing \r\n        if (newDuration <= 2) {\r\n            return;\r\n        }\r\n        resizeState.activeSegmentSide === 'left' ?\r\n            active.offsetStart = newTime :\r\n            active.end = newTime;\r\n        manager.flatten(resizeState.dragWave.id);\r\n        manager.process(resizeState.dragWave.id);\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n        resizeState.activeSegment = null;\r\n        resizeState.activeSegmentOffsetStart = 0;\r\n        resizeState.activeSegmentOffsetEnd = 0;\r\n        resizeState.activeSegmentSide = null;\r\n        resizeState.dragWave = null;\r\n        resizeState.options = null;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n *\r\n *\r\n * @export\r\n * @param waveform Sampled data for each pixel, max at 0, min at 1\r\n * @param options\r\n * @param ctx\r\n * @param color\r\n */\r\nexports.default = (function (waveform, options, ctx, color) {\r\n    var scale = options.height / 2;\r\n    var width = options.width;\r\n    ctx.fillStyle = color;\r\n    ctx.clearRect(0, 0, width, options.height);\r\n    for (var i = 0, inSegment = false, segmentStart = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        var pointInSegment = waveform[index + 3] === 1;\r\n        if (!inSegment && pointInSegment) {\r\n            inSegment = true;\r\n            segmentStart = i;\r\n        }\r\n        else if (inSegment && (!pointInSegment || i === width - 1)) {\r\n            inSegment = false;\r\n            ctx.fillRect(segmentStart, 0, i - segmentStart, options.height);\r\n        }\r\n    }\r\n    ctx.fillStyle = 'black';\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, scale);\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        ctx.lineTo(i, Math.round((waveform[index] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.moveTo(0, scale);\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        ctx.lineTo(i, Math.round((waveform[index + 1] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.closePath();\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        if (waveform[index - 4 + 2] === 0 && waveform[index + 2] === 1) {\r\n            ctx.rect(i, 0, 1, options.height);\r\n        }\r\n    }\r\n    ctx.fill();\r\n});\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = (function (manager, canvas, dragState) {\r\n    var enterlistener = function (ev) { return pointerEnter(ev); };\r\n    /**\r\n     * Fires when the mouse moves over the container,\r\n     * If a segment is being dragged and the pointer moves\r\n     * into another canvas the segment is tranfered to the\r\n     * new canvas.\r\n     */\r\n    canvas.addEventListener('pointermove', enterlistener);\r\n    var destroy = function () {\r\n        canvas.removeEventListener('pointermove', enterlistener);\r\n    };\r\n    var pointerEnter = function (ev) {\r\n        if (dragState.options == null || dragState.options.mode !== 'drag')\r\n            return;\r\n        if (dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n        var canvas = document.elementFromPoint(ev.clientX, ev.clientY);\r\n        if (canvas == null || !(canvas instanceof HTMLCanvasElement))\r\n            return;\r\n        var id = canvas.getAttribute('data-wave-id');\r\n        if (id == null)\r\n            return;\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        if (dragState.dragWave.id !== id) {\r\n            var index = dragState.dragWave.intervals.indexOf(dragState.activeSegment);\r\n            dragState.dragWave.intervals.splice(index, 1);\r\n            wave.intervals.push(dragState.activeSegment);\r\n            dragState.activeSegment.index = 1000;\r\n            var currentId = dragState.dragWave.id;\r\n            dragState.dragWave = wave;\r\n            manager.flatten(wave.id, currentId);\r\n            manager.process(wave.id, currentId);\r\n        }\r\n    };\r\n    return destroy;\r\n});\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(0);\r\nvar defaultDomOptions = __assign({}, waveshaper_1.defaultConfig, { mode: 'pan', height: 150, getEventTarget: function (ev) { return ev.target; }, generateId: function () { return Math.random().toString(); }, registerSetsActive: true });\r\nexports.default = defaultDomOptions;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.dragState = {\r\n    activeSegment: null,\r\n    activeSegmentStart: 0,\r\n    dragWave: null,\r\n    options: null,\r\n    duration: 0,\r\n    dragging: false\r\n};\r\n\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// waveshaper-dom.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d48635f3e273659c408a","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waveshaper\"] = factory();\n\telse\n\t\troot[\"waveshaper\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar peak_1 = __webpack_require__(1);\r\nvar rms_1 = __webpack_require__(2);\r\nvar flatten_1 = __webpack_require__(3);\r\nvar Track = /** @class */ (function () {\r\n    function Track(id, intervals) {\r\n        this.id = id;\r\n        this.intervals = intervals || [];\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    }\r\n    Object.defineProperty(Track.prototype, \"flattened\", {\r\n        get: function () { return this._flattened.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Track.prototype.flatten = function () {\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    };\r\n    /**\r\n     * Gets the duration of the audio in seconds\r\n     *\r\n     * @returns Decimal value of total duration in seconds\r\n     */\r\n    Track.prototype.getDuration = function () {\r\n        return Math.max.apply(Math, this.intervals.map(function (s) { return s.end; }));\r\n    };\r\n    /**\r\n     * Gets the summerized values for the current settings\r\n     *\r\n     * @param options\r\n     * @param dataMap\r\n     * @returns Two dimensional array, one entry for each pixel, for each pixel a min\r\n     * and a max value.\r\n     */\r\n    Track.prototype.calculate = function (options, dataMap) {\r\n        switch (options.meterType) {\r\n            case 'peak':\r\n                return peak_1.default(options, this.flattened, dataMap);\r\n            default:\r\n                return rms_1.default(options, this.flattened, dataMap);\r\n        }\r\n    };\r\n    return Track;\r\n}());\r\nexports.default = Track;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates peak values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var min = 0, max = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize) {\r\n            var sample = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (sample > max)\r\n                max = sample;\r\n            else if (sample < min)\r\n                min = sample;\r\n        }\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculate rms values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var posSum = 0, negSum = 0, count = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize, count++) {\r\n            var val = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (val > 0) {\r\n                posSum += val * val;\r\n            }\r\n            else {\r\n                negSum += val * val;\r\n            }\r\n        }\r\n        var min = -Math.sqrt(negSum / count);\r\n        var max = Math.sqrt(posSum / count);\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar start = function (segment) { return segment.start + segment.offsetStart; };\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param segments Segments to flatten\r\n * @returns flattened Interval array\r\n */\r\nexports.default = (function (segments) {\r\n    if (segments == null || segments.length === 0)\r\n        return [];\r\n    var sorted = sort(segments);\r\n    var normalized = normalizeIndex(sorted);\r\n    var copied = copy(normalized);\r\n    var grouped = groupByIndex(copied);\r\n    return weightedMerge(grouped);\r\n});\r\n/**\r\n * Copies elements so original are unaltered\r\n *\r\n * @param intervals\r\n */\r\nvar copy = function (intervals) { return intervals.map(function (i) { return (__assign({}, i)); }); };\r\n/**\r\n * When an element is altered the index is set very high,\r\n * this functions normalizes to indexes back to 0\r\n *\r\n * @param segments\r\n */\r\nvar normalizeIndex = function (segments) {\r\n    var index = 0;\r\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\r\n    segments.forEach(function (el) {\r\n        if (el.index > preNormalizeIndex) {\r\n            preNormalizeIndex = el.index;\r\n            el.index = ++index;\r\n        }\r\n        else {\r\n            el.index = index;\r\n        }\r\n    });\r\n    return segments;\r\n};\r\n/**\r\n * Sorts the intervals by index, then by start\r\n *\r\n * @param intervals\r\n * @return Interval array\r\n */\r\nvar sort = function (intervals) {\r\n    return intervals.sort(function (a, b) { return cmp(a.index, b.index) || cmp(start(a), start(b)); });\r\n};\r\n/**\r\n * Returns a map of intervals grouped by the key property\r\n *\r\n * @param intervals\r\n * @param key\r\n *\r\n * @returns Map of index => interval[]\r\n */\r\nvar groupByIndex = function (intervals) {\r\n    return intervals.reduce(function (groups, interval) {\r\n        (groups[interval.index] = groups[interval.index] || []).push(interval);\r\n        return groups;\r\n    }, {});\r\n};\r\n/**\r\n * Merges all the groups by index\r\n *\r\n * @param grouped\r\n * @returns Interval array\r\n */\r\nvar weightedMerge = function (grouped) {\r\n    var flattened = null;\r\n    for (var _i = 0, _a = Object.keys(grouped); _i < _a.length; _i++) {\r\n        var index = _a[_i];\r\n        var merged = merge(grouped[index]);\r\n        if (flattened == null) {\r\n            flattened = merged;\r\n        }\r\n        else {\r\n            flattened = combine(merged, flattened);\r\n        }\r\n    }\r\n    return flattened;\r\n};\r\n/**\r\n * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n *\r\n * @param intervals\r\n * @returns Interval array\r\n */\r\nvar merge = function (intervals) {\r\n    if (intervals.length <= 1)\r\n        return intervals;\r\n    var result = [];\r\n    var current = intervals[0];\r\n    for (var i = 1; i < intervals.length; i++) {\r\n        var next = intervals[i];\r\n        // If current is completely overlapped by second it is merged into it\r\n        if (current.end >= next.end) {\r\n            continue;\r\n            // Resolves partial overlaps by setting end of current to start of next\r\n        }\r\n        else if (start(next) < current.end) {\r\n            result.push(__assign({}, current, { end: start(next) }));\r\n            current = next;\r\n        }\r\n        else {\r\n            // No overlap, push onto results\r\n            result.push(current);\r\n            current = next;\r\n        }\r\n    }\r\n    result.push(current);\r\n    return result;\r\n};\r\n/**\r\n * Given two sets of intervals it merges them so the highIndexes set has priority\r\n *\r\n * @param highIndexes\r\n * @param lowIndexes\r\n *\r\n * @returns Interval array\r\n */\r\nvar combine = function (highIndexes, lowIndexes) {\r\n    var highIndex = 0;\r\n    var lowIndex = 0;\r\n    var merged = [];\r\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\r\n        var high = highIndexes[highIndex];\r\n        var low = lowIndexes[lowIndex];\r\n        // Only low priority left so push low onto results\r\n        if (highIndex === highIndexes.length) {\r\n            merged.push(__assign({}, low));\r\n            lowIndex++;\r\n            // Only high priority left so push high onto results\r\n        }\r\n        else if (lowIndex === lowIndexes.length) {\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // High priority start before or at same time as low\r\n        }\r\n        else if (start(high) <= start(low)) {\r\n            // No overlap between low and high\r\n            // low:                 ----------------------\r\n            // high: ---------------\r\n            if (high.end <= start(low)) {\r\n                // Partial overlap where high ends after low\r\n                // low:                 ----------------------\r\n                // high: ----------------------\r\n            }\r\n            else if (high.end < low.end) {\r\n                low.offsetStart = high.end - low.start;\r\n                // Low index completely overlapped, dismiss it\r\n                // low:               -----------\r\n                // high: -------------------------------------\r\n            }\r\n            else {\r\n                lowIndex++;\r\n            }\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // Low priority starts before high\r\n        }\r\n        else {\r\n            // No overlap between low and high intervals\r\n            // low: ---------------\r\n            // high                ----------------------\r\n            if (low.end <= start(high)) {\r\n                merged.push(__assign({}, low));\r\n                lowIndex++;\r\n                // Partial overlap where high ends after low\r\n                // low: ---------------------\r\n                // high                ----------------------\r\n            }\r\n            else if (high.end > low.end) {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                lowIndex++;\r\n                // Partial overlap where high ends before low\r\n                // low: -------------------------------------\r\n                // high             -----------\r\n            }\r\n            else {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                low.offsetStart = high.end - low.start;\r\n            }\r\n        }\r\n    }\r\n    return merged;\r\n};\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nvar cmp = function (a, b) {\r\n    if (a > b)\r\n        return +1;\r\n    if (a < b)\r\n        return -1;\r\n    return 0;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 10,\r\n    meterType: 'rms',\r\n    width: 300,\r\n    samplerate: 44100\r\n};\r\nexports.default = defaultOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(6);\r\nexports.WaveShaper = waveshaper_1.default;\r\nvar track_1 = __webpack_require__(0);\r\nexports.Track = track_1.default;\r\nvar managerconfig_1 = __webpack_require__(4);\r\nexports.defaultConfig = managerconfig_1.default;\r\nvar rms_1 = __webpack_require__(2);\r\nexports.rms = rms_1.default;\r\nvar peak_1 = __webpack_require__(1);\r\nexports.peak = peak_1.default;\r\nvar flatten_1 = __webpack_require__(3);\r\nexports.flatten = flatten_1.default;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar track_1 = __webpack_require__(0);\r\nvar managerconfig_1 = __webpack_require__(4);\r\n/**\r\n *\r\n *\r\n * @export\r\n */\r\nvar WaveShaper = /** @class */ (function () {\r\n    /**\r\n     * @param [options=defaultOptions] Initial options\r\n     * @throws Throws an error if samplerate is null or NaN\r\n     */\r\n    function WaveShaper(options) {\r\n        if (options === void 0) { options = managerconfig_1.default; }\r\n        /**\r\n         * Map of waveshapers managed by the manager\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.tracks = new Map();\r\n        /**\r\n         * Map of audio data\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.audioData = new Map();\r\n        /**\r\n         * @description Map of callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.callbackMap = new Map();\r\n        this._activeWaveShapers = [];\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, managerconfig_1.default, options);\r\n    }\r\n    Object.defineProperty(WaveShaper.prototype, \"options\", {\r\n        /**\r\n         * @description Currect settings\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"activeWaveShapers\", {\r\n        /**\r\n         * @description Active id's, redraws when draw is called without argument\r\n         *\r\n         * @readonly\r\n         * @unused\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._activeWaveShapers.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"lastProcessResult\", {\r\n        /**\r\n         * @description Last result of calling process, argument given to all callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._lastProcessResult; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"duration\", {\r\n        /**\r\n         * @description Total duration of all tracks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._duration; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gives the position corresponding to a given time\r\n     *\r\n     * @param time\r\n     */\r\n    WaveShaper.prototype.timeToPosition = function (time) {\r\n        return (time * this._options.samplerate) / this._options.samplesPerPixel;\r\n    };\r\n    /**\r\n     * Gives the time corresponding to a given position\r\n     * @param position\r\n     */\r\n    WaveShaper.prototype.positionToTime = function (position) {\r\n        return (position * this._options.samplesPerPixel) / this._options.samplerate;\r\n    };\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     *\r\n     * @param id\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.flatten = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.getProcessIds.apply(this, ids).forEach(function (id) {\r\n            var waveShaper = _this.getTrack(id);\r\n            if (waveShaper != null)\r\n                waveShaper.flatten();\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Processes all relevant WaveShapers and invokes registered callbacks\r\n     *\r\n     * @param ids Options array of id's to draw\r\n     * @param forceDraw Force redraw of the given waves\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.process = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        var toProcess = this.getProcessIds.apply(this, ids);\r\n        var options = __assign({}, this.options);\r\n        var data = [];\r\n        for (var i = 0; i < toProcess.length; i++) {\r\n            var id = toProcess[i];\r\n            var wave = this.getTrack(id);\r\n            if (wave == null)\r\n                continue;\r\n            var peaks = wave.calculate(options, this.audioData);\r\n            data.push({ id: id, data: peaks });\r\n        }\r\n        // Invoke callbacks after returning value.\r\n        this._lastProcessResult = { options: options, data: data };\r\n        this.invokeCallbacks(this._lastProcessResult);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a callback that fires when the track with given id is processed\r\n     *\r\n     * @param id id of Track to register to\r\n     * @param callBack will be invoked when the given track is processed\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.on = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null) {\r\n            this.callbackMap.set(id, [callBack]);\r\n        }\r\n        else {\r\n            callbackArray.push(callBack);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters a callback from the given track, will no longer be called\r\n     *\r\n     * @param id id of Track to unregister from\r\n     * @param callBack callback to remove\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.off = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return this;\r\n        var index = callbackArray.indexOf(callBack);\r\n        if (index < 0)\r\n            return this;\r\n        callbackArray = callbackArray.splice(index, 1);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Merges the given options into the current and returns updated options\r\n     *\r\n     * @param options A (partial) ManagerOptions object\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setOptions = function (options) {\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, this.options, options);\r\n        this.invokeOptionsCallbacks(this.options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     *\r\n     * @param id id of WaveShaper\r\n     * @param segments Segments in wave\r\n     * @param color Background color of segments\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setTracks = function () {\r\n        var tracks = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tracks[_i] = arguments[_i];\r\n        }\r\n        for (var i = 0; i < tracks.length; i++) {\r\n            var track = tracks[i];\r\n            var foundWave = this.getTrack(track.id);\r\n            if (foundWave == null) {\r\n                var wave = new track_1.default(track.id, track.intervals);\r\n                this.tracks.set(track.id, wave);\r\n            }\r\n            else {\r\n                foundWave.intervals = track.intervals || [];\r\n                foundWave.flatten();\r\n            }\r\n        }\r\n        this._duration = this.getDuration();\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds audio data to the waveshaper and redraws waveshapers using it\r\n     *\r\n     * @param id  Data id, refered to by source parameter of segments\r\n     * @param data AudioBuffer with audio data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setData = function () {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            data[_i] = arguments[_i];\r\n        }\r\n        data.forEach(function (d) {\r\n            _this.audioData.set(d.id, d.data);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description The given id's are set as the active waveshapers, process only processes these when set,\r\n     * call with no values to allways process all values (default)\r\n     *\r\n     * @param ids Waveshaper id's to set as active\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setActive = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this._activeWaveShapers = ids;\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Removes the waves and all callbacks with given id from the manager\r\n     *\r\n     * @param id\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.clearTracks = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        ids.forEach(function (id) {\r\n            _this.removeCallbacksById(id);\r\n            _this.tracks.delete(id);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Gets Track with given id\r\n     *\r\n     * @param id\r\n     * @returns Track with given ID\r\n     */\r\n    WaveShaper.prototype.getTrack = function (id) {\r\n        return this.tracks.get(id);\r\n    };\r\n    /**\r\n     * Validates given options\r\n     *\r\n     * @param options\r\n     * @returns true if valid, false if not\r\n     */\r\n    WaveShaper.prototype.optionsValid = function (options) {\r\n        return (options.samplesPerPixel === undefined || options.samplesPerPixel > 0) &&\r\n            (options.meterType === undefined || options.meterType) &&\r\n            (options.resolution === undefined || options.resolution > 0) &&\r\n            (options.width === undefined || options.width > 0) &&\r\n            (options.scrollPosition === undefined || options.scrollPosition >= 0) &&\r\n            (options.samplerate === undefined || options.samplerate > 0);\r\n    };\r\n    /**\r\n     * Invokes all registered callbacks registered to a waveshaper id in the data list\r\n     *\r\n     * @param options\r\n     * @param data\r\n     */\r\n    WaveShaper.prototype.invokeCallbacks = function (result) {\r\n        for (var i = 0; i < result.data.length; i++) {\r\n            var trackResult = result.data[i];\r\n            var callbacks = this.callbackMap.get(trackResult.id);\r\n            if (callbacks == null)\r\n                continue;\r\n            for (var j = 0; j < callbacks.length; j++) {\r\n                var callback = callbacks[j];\r\n                callback(result.options, new Float32Array(trackResult.data));\r\n            }\r\n        }\r\n    };\r\n    WaveShaper.prototype.invokeOptionsCallbacks = function (options) {\r\n        var callbacks = this.callbackMap.get('options');\r\n        if (callbacks == null)\r\n            return;\r\n        callbacks.forEach(function (cb) { return cb(options, null); });\r\n    };\r\n    WaveShaper.prototype.getProcessIds = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        if (ids.length > 0)\r\n            return ids;\r\n        if (this._activeWaveShapers.length > 0)\r\n            return this._activeWaveShapers;\r\n        return Array.from(this.tracks.keys());\r\n    };\r\n    WaveShaper.prototype.removeCallbacksById = function (id) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return;\r\n        callbackArray.splice(0, callbackArray.length);\r\n        this.callbackMap.delete(id);\r\n    };\r\n    /**\r\n     * @description Returns the maximum duration of all the waveshapers managed by this class\r\n     *\r\n     * @returns Maximum duration in seconds\r\n     * @memberof WaveShaper\r\n     */\r\n    WaveShaper.prototype.getDuration = function () {\r\n        return Array.from(this.tracks.values()).reduce(function (maxDuration, waveShaper) {\r\n            var duration = waveShaper.getDuration();\r\n            return duration > maxDuration ? duration : maxDuration;\r\n        }, 0);\r\n    };\r\n    return WaveShaper;\r\n}());\r\nexports.default = WaveShaper;\r\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=waveshaper.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/waveshaper/dist/waveshaper.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammerjs\",\"umd\":\"hammerjs\"}\n// module id = 1\n// module chunks = 0","import DomRenderWaveShaper from './core/domrender-waveshaper';\r\n\r\nexport {\r\n    DomRenderWaveShaper\r\n}\r\n\r\nexport default new DomRenderWaveShaper();\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import { WaveShaper } from \"waveshaper\";\r\nimport * as Hammer from \"hammerjs\";\r\n\r\nimport hammerConfig from '../config/hammerconfig';\r\nimport cut from '../interactions/cut';\r\nimport drag from '../interactions/drag';\r\nimport pan from '../interactions/pan';\r\nimport zoom from '../interactions/zoom';\r\nimport resize from '../interactions/resize';\r\nimport line from '../render/line';\r\nimport enter from '../interactions/enter';\r\nimport defaultDomOptions, { DomInput, DomOptions } from \"../config/dom-config\";\r\nimport { dragState } from \"../models/dragstate\";\r\n\r\n/**\r\n * Extends WaveShapeManager to allow for easy canvas rendering registration.\r\n * \r\n * @inheritDoc\r\n */\r\nexport default class DomRenderWaveShaper extends WaveShaper {\r\n    private unregister = () => {};\r\n\r\n    private unregisterMap = new Map<string, () => void>();\r\n    private canvasMap = new Map<string, () => void>();\r\n\r\n    public get scrollWidth(): number { return (this._duration * this._options.samplerate) / this._options.samplesPerPixel }\r\n\r\n    public get options(): DomOptions { return { ...this._options }; }\r\n    protected _options: DomOptions;\r\n\r\n    public get hammer(): HammerManager | null { return this._hammer; }\r\n    protected _hammer: HammerManager | null;\r\n\r\n    constructor(options: DomInput = defaultDomOptions) {\r\n        super(options);\r\n\r\n        this._options = { ...defaultDomOptions, ...this._options };\r\n    }\r\n\r\n    setOptions(input: DomInput) {\r\n        this._options = { ...this._options, ...input };\r\n        this.invokeOptionsCallbacks(this.options);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @description When a canvas is registered through this method each time the \r\n     * waveform is updated the canvas will be rerendered.\r\n     * \r\n     * It returns an unregister method, call to stop receiving callbacks.\r\n     * \r\n     * @param id WaveShaper id to register to.\r\n     * @param canvas Canvas to render to\r\n     * @param color Background color of segments\r\n     */\r\n    registerCanvas(id: string, canvas: HTMLCanvasElement, color: string): DomRenderWaveShaper {\r\n        const ctx = canvas.getContext('2d');\r\n        if(ctx == null) throw Error('Cannot get context from canvas.');\r\n\r\n        // Add classes and data attributes\r\n        canvas.classList.add('waveshaper');\r\n        canvas.setAttribute('data-wave-id', id);\r\n\r\n        canvas.style.width = this.options.width + 'px';\r\n        canvas.style.height = this.options.height + 'px';\r\n\r\n        const scale = (devicePixelRatio || 1) < 1 ? 1 : (devicePixelRatio || 1);\r\n\r\n        canvas.width = this.options.width * scale;\r\n        canvas.height = this.options.height;\r\n        \r\n        ctx.scale(scale, 1)\r\n\r\n        const callBack = (options: DomOptions, data: Float32Array) => line(data, options, ctx, color)\r\n        this.on(id, callBack);\r\n\r\n        this.unregisterCanvas(id);\r\n\r\n        \r\n        this.canvasMap.set(id, () => this.off(id, callBack));\r\n\r\n        const unregister = enter(this, canvas, dragState);\r\n        this.unregisterMap.set(id, unregister);\r\n\r\n        // If registerSetsActive is true \r\n        if(this._options.registerSetsActive) {\r\n            this.setActive(...this.activeWaveShapers.concat(id));\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clears the callbacks associated with this canvas\r\n     * \r\n     * @param id \r\n     * @returns Instance of WaveShaper\r\n     */\r\n    unregisterCanvas(id: string): DomRenderWaveShaper {\r\n        const unregister = this.canvasMap.get(id);\r\n        if(unregister != null) {\r\n            unregister();\r\n            this.canvasMap.delete(id);\r\n        }\r\n\r\n        const unregisterEvents = this.unregisterMap.get(id);\r\n        if(unregisterEvents != null) {\r\n            unregisterEvents();\r\n            this.unregisterMap.delete(id);\r\n        }\r\n\r\n        if(this._options.registerSetsActive) {\r\n            const index = this.activeWaveShapers.indexOf(id);\r\n            if(index != -1) this.setActive(...this.activeWaveShapers.splice(index, 1));\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Loads and saves a set of url's to audio files.\r\n     * \r\n     * @param ctx \r\n     * @param data \r\n     */\r\n    loadData(ctx: AudioContext, ...data: { id: string, url: string }[]): DomRenderWaveShaper {\r\n        data.forEach(dat => {\r\n            fetch(dat.url)\r\n            .then(res => res.arrayBuffer())\r\n            .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))\r\n            .then(audioBuffer => {\r\n                this.setData({ id: dat.id, data: audioBuffer.getChannelData(0) }).process();\r\n            })\r\n            .catch(e => console.log(e));\r\n        });\r\n        \r\n        return this;\r\n    }\r\n\r\n    setInteraction(element: HTMLElement) {\r\n        if(element == null) throw Error('Interaction container element could not be found.');\r\n        this.unregister();\r\n\r\n        element.setAttribute('touch-action', 'none');\r\n        \r\n        const hammer = new Hammer(element, hammerConfig);\r\n        this._hammer = hammer;\r\n    \r\n        drag(this, hammer, dragState);\r\n        cut(this, hammer);\r\n        pan(this, hammer);\r\n        zoom(this, hammer);\r\n        resize(this, hammer);\r\n    \r\n        this.unregister = () => {\r\n            hammer.destroy();\r\n        };\r\n\r\n        return this;\r\n    }\r\n\r\n    clearInteraction() {\r\n        this.unregister();\r\n        this.unregister = () => { };\r\n\r\n        this._hammer = null;\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/core/domrender-waveshaper.ts","import * as Hammer from 'hammerjs';\r\n\r\nconst hammerOptions: HammerOptions = {\r\n    touchAction : 'pan-y',\r\n    recognizers: [\r\n        [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }],\r\n        [Hammer.Pinch, { enable : true }],\r\n        [Hammer.Tap]\r\n    ]\r\n}\r\n\r\nexport default hammerOptions;\n\n\n// WEBPACK FOOTER //\n// ./src/config/hammerconfig.ts","import { Interval } from 'waveshaper';\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager) => {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'cut' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('tap', (ev: HammerInput) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(options == null || !shouldHandle(target, options))\r\n            return;\r\n\r\n        // Allready checked for null\r\n        const id = <string>target.getAttribute('data-wave-id');\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n        if(interval == null) return;\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        const newSegment: Interval = { \r\n            ...segment, \r\n            offsetStart: time - segment.start,\r\n            id: options.generateId() \r\n        };\r\n\r\n        segment.end = time;\r\n        wave.intervals.push(newSegment);\r\n        \r\n        manager.flatten(wave.id);\r\n        manager.process(wave.id);\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/cut.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\nimport { DragState } from '../models/dragstate';\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager Waveshape Manager\r\n * @param hammer Hammer instance\r\n * @param container Container element\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager, dragState: DragState) => {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'drag' && target.hasAttribute('data-wave-id');\r\n\r\n    /**\r\n     * Sets up the drag by finding the \r\n     */\r\n    hammer.on('panstart', (ev: HammerInput) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n\r\n        // Allready checked for existance\r\n        const id = <string>target.getAttribute('data-wave-id');\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n\r\n        if (interval == null)\r\n            return;\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        if(ev.srcEvent instanceof PointerEvent) { \r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n\r\n        dragState.options = options;\r\n\r\n        dragState.activeSegment = segment;\r\n        dragState.activeSegmentStart = dragState.activeSegment.start;\r\n        dragState.duration = segment.end - segment.start;\r\n\r\n        dragState.activeSegment.index = 1000;\r\n        dragState.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('panmove', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || dragState.activeSegment == null || dragState.dragWave == null \r\n            || dragState.dragging || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        dragState.dragging = true;\r\n\r\n        /** \r\n         * TODO below implementation stops all updates on touch devices on new track (tested on Samsung Galaxy s8),\r\n         * when dragged back to original keeps working. Works on desktop, it's a small performance improvement as\r\n         * it prevents a single track flatten + process when transferring a segment between tracks.\r\n         */\r\n\r\n        //// If the target has moved it is handled by the mouseHover function\r\n        // const id = ev.target.getAttribute('data-wave-id');\r\n        // if(id !== dragState.dragWave.id)\r\n        //     return;\r\n\r\n        const change = (ev.deltaX * dragState.options.samplesPerPixel) / dragState.options.samplerate;\r\n        let newTime = dragState.activeSegmentStart + change;\r\n\r\n        if (newTime + dragState.activeSegment.offsetStart < 0) {\r\n            newTime = -dragState.activeSegment.offsetStart;\r\n        }\r\n\r\n        dragState.activeSegment.start = newTime;\r\n        dragState.activeSegment.end = newTime + dragState.duration;\r\n\r\n        manager.flatten(dragState.dragWave.id);\r\n        manager.process(dragState.dragWave.id);\r\n\r\n        dragState.dragging = false;\r\n    });\r\n\r\n    hammer.on('panend', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        dragState.activeSegment = null;\r\n        dragState.activeSegmentStart = 0;\r\n        dragState.dragWave = null;\r\n        dragState.options = null;\r\n        dragState.duration = 0;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/drag.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface PanState {\r\n    panStart: number;\r\n    panMax: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst panState: PanState = {\r\n    panStart: 0,\r\n    panMax: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pan functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        if(ev.srcEvent instanceof PointerEvent) { \r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n\r\n        panState.panMax = manager.scrollWidth + endMargin;\r\n        panState.panStart = options.scrollPosition;\r\n    });\r\n\r\n    hammer.on('panmove', (ev) =>  {\r\n        panState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n\r\n        if(!shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        const position = panState.panStart - ev.deltaX;\r\n        const newPosition = position > 0 ? position : 0;\r\n\r\n        // If it was and is still 0 no need to update\r\n        if(newPosition === panState.options.scrollPosition)\r\n            return;\r\n\r\n        if(newPosition > panState.panMax - panState.options.width)\r\n            return;\r\n        \r\n        manager.setOptions({ scrollPosition: newPosition }).process();\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(panState.options == null || !shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        panState.options = null;\r\n        panState.panStart = 0;\r\n        panState.panMax = 0;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/pan.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface ZoomState {\r\n    maxWidth: number;\r\n    sppStart: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst zoomState: ZoomState = {\r\n    maxWidth: 0,\r\n    sppStart: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pinch zoom functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('pinchstart', (ev) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        if(ev.srcEvent instanceof PointerEvent) { \r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n\r\n        zoomState.sppStart = options.samplesPerPixel;\r\n        zoomState.maxWidth = manager.scrollWidth + endMargin;\r\n    });\r\n\r\n    hammer.on('pinchmove', (ev) => {\r\n        zoomState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n\r\n        const sampleAtLeft = zoomState.options.scrollPosition * zoomState.options.samplesPerPixel;\r\n        const samplesInView = zoomState.options.width * zoomState.options.samplesPerPixel;\r\n        const samplesToCenter = samplesInView / 2;\r\n\r\n        const newSpp = zoomState.sppStart * ev.scale;\r\n\r\n        const newSamplesInView = zoomState.options.width * newSpp;\r\n        const newSamplesToCenter = newSamplesInView / 2;\r\n\r\n        const maxWidth = manager.scrollWidth + endMargin;\r\n        const maxSamplesInView = maxWidth  * zoomState.options.samplerate;\r\n\r\n        if(newSamplesInView >= maxSamplesInView)\r\n            return;\r\n\r\n        const newScroll = (sampleAtLeft + samplesToCenter - newSamplesToCenter) / newSpp;\r\n\r\n        manager.setOptions({\r\n            samplesPerPixel: newSpp,\r\n            scrollPosition: newScroll >= 0 ? newScroll : 0\r\n        }).process();\r\n    });\r\n\r\n    hammer.on('pinchend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n\r\n        zoomState.sppStart = 0;\r\n        zoomState.maxWidth = 0;\r\n        zoomState.options = null;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/zoom.ts","import { Interval, Track } from 'waveshaper';\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\ndeclare type SegmentSide = 'left' | 'right';\r\n\r\ninterface ResizeState {\r\n    activeSegment: Interval | null;\r\n    activeSegmentSide: SegmentSide | null;\r\n    activeSegmentOffsetStart: number;\r\n    activeSegmentOffsetEnd: number;\r\n    dragWave: Track | null;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst resizeState: ResizeState = {\r\n    activeSegment: null,\r\n    activeSegmentSide: null,\r\n    activeSegmentOffsetStart: 0,\r\n    activeSegmentOffsetEnd: 0,\r\n    dragWave: null,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'resize' && target != null && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        \r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        // Already checked that it exists\r\n        const id = <string>target.getAttribute('data-wave-id');\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = target.getBoundingClientRect();\r\n        const time = ((options.scrollPosition + (ev.center.x - bb.left)) * options.samplesPerPixel) / options.samplerate;\r\n\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n\r\n        if(interval == null) \r\n            return;\r\n\r\n        resizeState.activeSegmentSide = \r\n            time < interval.start + interval.offsetStart + ((interval.end - (interval.start + interval.offsetStart)) / 2) ? \r\n                'left' : \r\n                'right';\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        if(ev.srcEvent instanceof PointerEvent) { \r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n\r\n        resizeState.options = options;\r\n        resizeState.activeSegment = segment;\r\n\r\n        resizeState.activeSegmentOffsetStart = segment.offsetStart;\r\n        resizeState.activeSegmentOffsetEnd = segment.end;\r\n\r\n        segment.index = 1000;\r\n        resizeState.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('panmove', (ev) =>  {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(resizeState.dragWave == null || resizeState.activeSegment == null || resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n\r\n        const options = manager.options;\r\n\r\n        const change = (ev.deltaX * options.samplesPerPixel) / options.samplerate;\r\n        let newTime = resizeState.activeSegmentSide === 'left' ?\r\n            resizeState.activeSegmentOffsetStart + change :\r\n            resizeState.activeSegmentOffsetEnd + change;\r\n\r\n        // Don't allow offset to become less than 0\r\n        if(newTime < 0) {\r\n            newTime = 0;\r\n        }\r\n\r\n        const active = resizeState.activeSegment;\r\n        const newDuration = resizeState.activeSegmentSide === 'left' ?\r\n            active.end - active.start - newTime :\r\n            newTime - active.start - active.offsetStart;\r\n\r\n        // Do not allow resizing \r\n        if(newDuration <= 2) {\r\n            return;\r\n        }\r\n        \r\n        resizeState.activeSegmentSide === 'left' ?\r\n            active.offsetStart = newTime :\r\n            active.end = newTime;\r\n\r\n        manager.flatten(resizeState.dragWave.id);\r\n        manager.process(resizeState.dragWave.id);\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n\r\n        resizeState.activeSegment = null;\r\n        resizeState.activeSegmentOffsetStart = 0;\r\n        resizeState.activeSegmentOffsetEnd = 0;\r\n        resizeState.activeSegmentSide = null;\r\n        resizeState.dragWave = null;\r\n        resizeState.options = null;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/resize.ts","import { DomOptions } from \"../config/dom-config\";\r\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param waveform Sampled data for each pixel, max at 0, min at 1 \r\n * @param options\r\n * @param ctx \r\n * @param color\r\n */\r\nexport default (waveform: Float32Array, options: DomOptions, ctx: CanvasRenderingContext2D, color: string) => {\r\n    const scale = options.height / 2;\r\n    const width = options.width;\r\n    \r\n    ctx.fillStyle = color;\r\n    ctx.clearRect(0, 0, width, options.height);\r\n    \r\n    for(let i = 0, inSegment = false, segmentStart = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        const pointInSegment = waveform[index + 3] === 1;\r\n        if(!inSegment && pointInSegment) {\r\n            inSegment = true;\r\n            segmentStart = i;\r\n        } else if (inSegment && (!pointInSegment || i === width - 1)) {\r\n            inSegment = false;\r\n            ctx.fillRect(segmentStart, 0, i - segmentStart, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fillStyle = 'black';\r\n    ctx.beginPath();\r\n    \r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n\r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index + 1] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.closePath();\r\n\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        if(waveform[index - 4 + 2] === 0 && waveform[index + 2] === 1) {\r\n            ctx.rect(i, 0, 1, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fill();\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/render/line.ts","import { DragState } from \"../models/dragstate\";\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\n\r\nexport default (manager: DomRenderWaveShaper, canvas: HTMLCanvasElement, dragState: DragState): () => void => {\r\n\r\n    const enterlistener = (ev: PointerEvent) => pointerEnter(ev);\r\n\r\n\r\n    /**\r\n     * Fires when the mouse moves over the container,\r\n     * If a segment is being dragged and the pointer moves\r\n     * into another canvas the segment is tranfered to the \r\n     * new canvas.\r\n     */\r\n    canvas.addEventListener('pointermove', enterlistener);\r\n\r\n    const destroy = () => {\r\n        canvas.removeEventListener('pointermove', enterlistener);\r\n    }\r\n\r\n    const pointerEnter = (ev: PointerEvent) => {\r\n        if (dragState.options == null || dragState.options.mode !== 'drag')\r\n            return;\r\n\r\n        if(dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n\r\n        const canvas = document.elementFromPoint(ev.clientX, ev.clientY);\r\n        if (canvas == null || !(canvas instanceof HTMLCanvasElement))\r\n            return;\r\n\r\n        const id = canvas.getAttribute('data-wave-id');\r\n        if (id == null) return;\r\n\r\n        const wave = manager.getTrack(id);\r\n        if (wave == null) return;\r\n\r\n        if (dragState.dragWave.id !== id) {\r\n            const index = dragState.dragWave.intervals.indexOf(dragState.activeSegment);\r\n            dragState.dragWave.intervals.splice(index, 1);\r\n\r\n            wave.intervals.push(dragState.activeSegment);\r\n            dragState.activeSegment.index = 1000;\r\n\r\n            const currentId = dragState.dragWave.id;\r\n            dragState.dragWave = wave;\r\n\r\n            manager.flatten(wave.id, currentId);\r\n            manager.process(wave.id, currentId);\r\n        }\r\n    }\r\n\r\n    return destroy;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/enter.ts","import { defaultConfig, ManagerOptions, ManagerInput } from \"waveshaper\";\r\n\r\nexport type InteractionMode = 'pan' | 'drag' | 'cut' | 'resize';\r\nexport type GenerateId = () => string;\r\nexport type GetTarget = (ev: Event) => HTMLElement;\r\n\r\n\r\nexport interface DomOptions extends ManagerOptions {\r\n    getEventTarget: GetTarget;\r\n    registerSetsActive: boolean;\r\n    height: number;\r\n    generateId: GenerateId;\r\n    mode: InteractionMode;\r\n}\r\n\r\nexport interface DomInput extends ManagerInput {\r\n    getEventTarget?: GetTarget;\r\n    registerSetsActive?: boolean;\r\n    height?: number;\r\n    generateId?: GenerateId;\r\n    mode?: InteractionMode;\r\n}\r\n\r\nconst defaultDomOptions: DomOptions = {\r\n    ...defaultConfig,\r\n    mode: 'pan',\r\n    height: 150,\r\n    getEventTarget: (ev) => <HTMLElement>ev.target,\r\n    generateId: () => Math.random().toString(),\r\n    registerSetsActive: true \r\n}\r\n\r\nexport default defaultDomOptions;\n\n\n// WEBPACK FOOTER //\n// ./src/config/dom-config.ts","import { Interval, Track } from \"waveshaper\";\r\nimport { DomOptions } from \"../config/dom-config\";\r\n\r\nexport interface DragState {\r\n    activeSegment: Interval | null;\r\n    activeSegmentStart: number;\r\n    dragWave: Track | null;\r\n    options: DomOptions | null;\r\n    duration: number;\r\n    dragging: boolean;\r\n}\r\n\r\nexport const dragState: DragState = {\r\n    activeSegment: null,\r\n    activeSegmentStart: 0,\r\n    dragWave: null,\r\n    options: null,\r\n    duration: 0,\r\n    dragging: false\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/models/dragstate.ts"],"sourceRoot":""}