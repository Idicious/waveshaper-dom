{"version":3,"sources":["webpack://WS/webpack/universalModuleDefinition","webpack://WS/webpack/bootstrap","webpack://WS/./node_modules/waveshaper/dist/waveshaper.js","webpack://WS/external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammerjs\",\"umd\":\"hammerjs\"}","webpack://WS/./src/index.ts","webpack://WS/./src/core/domrender-waveshaper.ts","webpack://WS/./src/config/hammerconfig.ts","webpack://WS/./src/interactions/cut.ts","webpack://WS/./src/interactions/drag.ts","webpack://WS/./src/interactions/pan.ts","webpack://WS/./src/interactions/zoom.ts","webpack://WS/./src/interactions/resize.ts","webpack://WS/./src/render/line.ts","webpack://WS/./src/interactions/enter.ts","webpack://WS/./src/config/dom-config.ts","webpack://WS/./src/models/dragstate.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","self","configurable","peak_1","rms_1","weighted_interval_merge_1","Track","id","intervals","width","this","_lastValue","Float32Array","_flattened","weightedIntervalMerge","slice","flatten","getDuration","Math","max","apply","map","end","calculate","options","dataMap","start","shift","meterType","default","flattened","startPosition","lastValue","sampleSize","ceil","samplesPerPixel","resolution","startSecond","scrollPosition","samplerate","secondsPerPixel","calcStartSecond","calcEndSecond","absShift","abs","shiftTarget","shiftStart","peaks","buffer","copyWithin","fill","currentIntervalIndex","findIndex","offsetStart","maxIntervalIncrementIndex","length","currentInterval","source","currentSecond","set","startBorder","endBorder","intervalBorder","secondsIntoInterval","startSample","floor","endSample","length_1","loopEnd","min","j","sample","posSum","negSum","count","val","sqrt","waveshaper_1","WaveShaper","track_1","managerconfig_1","defaultConfig","rms","peak","flatten_1","__assign","assign","arguments","tracks","Map","audioData","callbackMap","segmentCallbackMap","Array","optionsCallbacks","_activeWaveShapers","validateOptions","_options","_lastProcessResult","_duration","timeToPosition","time","positionToTime","position","ids","_this","getProcessIds","forEach","waveShaper","getTrack","process","toProcess","data","wave","push","invokeCallbacks","on","callBack","callbackArray","off","index","indexOf","splice","onSegment","cb","offSegment","emitSegment","old","changed","onOptions","offOptions","emitOptions","updated","setOptions","oldOptions","setTracks","_i","track","foundWave","setData","setActive","clearTracks","removeCallbacksById","delete","currentOptions","result","trackResult","callbacks","callback","from","keys","values","reduce","maxDuration","duration","_extends","target","calcStart","interval","copy","normalizeIndex","preNormalizeIndex","Number","MIN_SAFE_INTEGER","el","sort","a","b","cmp","groupByIndex","groups","weightedMerge","grouped","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterator","next","done","merged","merge","combine","err","return","current","highIndexes","lowIndexes","highIndex","lowIndex","high","low","sorted","normalized","copied","segment","segments","_a","domrender_waveshaper_1","DomRenderWaveShaper","Hammer","hammerconfig_1","cut_1","drag_1","pan_1","zoom_1","resize_1","line_1","enter_1","dom_config_1","dragstate_1","_super","unregister","unregisterMap","canvasMap","cutCallbacks","__extends","_hammer","input","registerCanvas","canvas","color","ctx","getContext","Error","classList","add","setAttribute","style","height","scale","devicePixelRatio","unregisterCanvas","dragState","registerSetsActive","activeWaveShapers","concat","unregisterEvents","filter","trackId","emitCut","original","left","right","onCut","loadData","dat","fetch","url","then","res","arrayBuffer","decodeAudioData","audioBuffer","getChannelData","catch","e","console","log","setInteraction","element","hammer","destroy","clearInteraction","hammerOptions","touchAction","recognizers","Pan","direction","DIRECTION_HORIZONTAL","Pinch","enable","Tap","manager","ev","getEventTarget","srcEvent","hasAttribute","shouldHandle","getAttribute","bb","getBoundingClientRect","deltaX","center","x","clampFn","find","generateId","startState","PointerEvent","setPointerCapture","pointerId","activeSegment","activeSegmentStart","dragWave","dragging","change","newTime","endMargin","panState","panStart","panMax","scrollWidth","newPosition","zoomState","maxWidth","sppStart","sampleAtLeft","samplesToCenter","newSpp","newSamplesInView","newSamplesToCenter","newScroll","resizeState","activeSegmentSide","activeSegmentOffsetStart","activeSegmentOffsetEnd","active","waveform","fillStyle","clearRect","inSegment","segmentStart","pointInSegment","fillRect","beginPath","moveTo","lineTo","round","closePath","rect","enterlistener","pointerEnter","addEventListener","document","elementFromPoint","clientX","clientY","HTMLCanvasElement","currentId","removeEventListener","defaultDomOptions","random","toString"],"mappings":"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","file":"waveshaper-dom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hammerjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hammerjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WS\"] = factory(require(\"hammerjs\"));\n\telse\n\t\troot[\"WS\"] = factory(root[\"Hammer\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waveshaper\"] = factory();\n\telse\n\t\troot[\"waveshaper\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar peak_1 = __webpack_require__(1);\r\nvar rms_1 = __webpack_require__(2);\r\nvar weighted_interval_merge_1 = __webpack_require__(6);\r\nvar Track = /** @class */ (function () {\r\n    function Track(id, intervals, width) {\r\n        this.width = width;\r\n        this._lastValue = new Float32Array(this.width * 4);\r\n        this.id = id;\r\n        this.intervals = intervals || [];\r\n        this._flattened = weighted_interval_merge_1.weightedIntervalMerge(this.intervals);\r\n    }\r\n    Object.defineProperty(Track.prototype, \"flattened\", {\r\n        get: function () {\r\n            return this._flattened.slice();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Track.prototype.flatten = function () {\r\n        this._flattened = weighted_interval_merge_1.weightedIntervalMerge(this.intervals);\r\n    };\r\n    /**\r\n     * Gets the duration of the audio in seconds\r\n     *\r\n     * @returns Decimal value of total duration in seconds\r\n     */\r\n    Track.prototype.getDuration = function () {\r\n        return Math.max.apply(Math, this.intervals.map(function (s) { return s.end; }));\r\n    };\r\n    /**\r\n     * Gets the summerized values for the current settings\r\n     *\r\n     * @param options\r\n     * @param dataMap\r\n     * @returns Two dimensional array, one entry for each pixel, for each pixel a min\r\n     * and a max value.\r\n     */\r\n    Track.prototype.calculate = function (options, dataMap, start, width, shift) {\r\n        switch (options.meterType) {\r\n            case \"peak\":\r\n                this._lastValue = peak_1.default(options, this.flattened, dataMap, start, width, shift, this._lastValue);\r\n                break;\r\n            default:\r\n                this._lastValue = rms_1.default(options, this.flattened, dataMap, start, width, shift, this._lastValue);\r\n                break;\r\n        }\r\n        return this._lastValue;\r\n    };\r\n    return Track;\r\n}());\r\nexports.default = Track;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates peak values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap, startPosition, width, shift, lastValue) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var calcStartSecond = startSecond + startPosition * secondsPerPixel;\r\n    var calcEndSecond = calcStartSecond + width * secondsPerPixel;\r\n    var absShift = Math.abs(shift) * 4;\r\n    var shiftTarget = shift > 0 ? 0 : absShift;\r\n    var shiftStart = shift > 0 ? absShift : 0;\r\n    var peaks = new Float32Array(lastValue.buffer)\r\n        .copyWithin(shiftTarget, shiftStart)\r\n        .fill(0, startPosition * 4, (startPosition + width) * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > calcStartSecond && i.start + i.offsetStart < calcEndSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = startPosition; i < startPosition + width; i++) {\r\n        var currentSecond = startSecond + i * secondsPerPixel;\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            peaks.set([0, 0, 0, 0], i * 4);\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel <\r\n            currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], i * 4);\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var min = 0, max = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize) {\r\n            var sample = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (sample > max)\r\n                max = sample;\r\n            else if (sample < min)\r\n                min = sample;\r\n        }\r\n        peaks.set([min, max, intervalBorder, 1], i * 4);\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculate rms values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap, startPosition, width, shift, lastValue) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var calcStartSecond = startSecond + startPosition * secondsPerPixel;\r\n    var calcEndSecond = calcStartSecond + width * secondsPerPixel;\r\n    var absShift = Math.abs(shift) * 4;\r\n    var shiftTarget = shift > 0 ? 0 : absShift;\r\n    var shiftStart = shift > 0 ? absShift : 0;\r\n    var peaks = new Float32Array(lastValue.buffer)\r\n        .copyWithin(shiftTarget, shiftStart)\r\n        .fill(0, startPosition * 4, (startPosition + width) * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > calcStartSecond && i.start + i.offsetStart < calcEndSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1) {\r\n        return peaks;\r\n    }\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = startPosition; i < startPosition + width; i++) {\r\n        var currentSecond = startSecond + i * secondsPerPixel;\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            peaks.set([0, 0, 0, 0], i * 4);\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel <\r\n            currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], i * 4);\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var posSum = 0, negSum = 0, count = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize, count++) {\r\n            var val = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (val > 0) {\r\n                posSum += val * val;\r\n            }\r\n            else {\r\n                negSum += val * val;\r\n            }\r\n        }\r\n        var min = -Math.sqrt(negSum / count);\r\n        var max = Math.sqrt(posSum / count);\r\n        peaks.set([min, max, intervalBorder, 1], i * 4);\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 10,\r\n    meterType: 'rms',\r\n    width: 300,\r\n    samplerate: 44100\r\n};\r\nexports.default = defaultOptions;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(5);\r\nexports.WaveShaper = waveshaper_1.default;\r\nvar track_1 = __webpack_require__(0);\r\nexports.Track = track_1.default;\r\nvar managerconfig_1 = __webpack_require__(3);\r\nexports.defaultConfig = managerconfig_1.default;\r\nvar rms_1 = __webpack_require__(2);\r\nexports.rms = rms_1.default;\r\nvar peak_1 = __webpack_require__(1);\r\nexports.peak = peak_1.default;\r\nvar flatten_1 = __webpack_require__(7);\r\nexports.flatten = flatten_1.default;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar track_1 = __webpack_require__(0);\r\nvar managerconfig_1 = __webpack_require__(3);\r\n/**\r\n *\r\n *\r\n * @export\r\n */\r\nvar WaveShaper = /** @class */ (function () {\r\n    /**\r\n     * @param [options=defaultOptions] Initial options\r\n     * @throws Throws an error if samplerate is null or NaN\r\n     */\r\n    function WaveShaper(options) {\r\n        if (options === void 0) { options = managerconfig_1.default; }\r\n        /**\r\n         * Map of waveshapers managed by the manager\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.tracks = new Map();\r\n        /**\r\n         * Map of audio data\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.audioData = new Map();\r\n        /**\r\n         * @description Map of callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.callbackMap = new Map();\r\n        /**\r\n         * @description Segment callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.segmentCallbackMap = new Array();\r\n        /**\r\n         * @description Options callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.optionsCallbacks = new Array();\r\n        this._activeWaveShapers = [];\r\n        this.validateOptions(options);\r\n        this._options = __assign({}, managerconfig_1.default, options);\r\n    }\r\n    Object.defineProperty(WaveShaper.prototype, \"options\", {\r\n        /**\r\n         * @description Currect settings\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () {\r\n            return __assign({}, this._options);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"activeWaveShapers\", {\r\n        /**\r\n         * @description Active id's, redraws when draw is called without argument\r\n         *\r\n         * @readonly\r\n         * @unused\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () {\r\n            return this._activeWaveShapers.slice();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"lastProcessResult\", {\r\n        /**\r\n         * @description Last result of calling process, argument given to all callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () {\r\n            return this._lastProcessResult;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"duration\", {\r\n        /**\r\n         * @description Total duration of all tracks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () {\r\n            return this._duration;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gives the position corresponding to a given time\r\n     *\r\n     * @param time\r\n     */\r\n    WaveShaper.prototype.timeToPosition = function (time) {\r\n        return (time * this._options.samplerate) / this._options.samplesPerPixel;\r\n    };\r\n    /**\r\n     * Gives the time corresponding to a given position\r\n     * @param position\r\n     */\r\n    WaveShaper.prototype.positionToTime = function (position) {\r\n        return ((position * this._options.samplesPerPixel) / this._options.samplerate);\r\n    };\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     *\r\n     * @param id\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.flatten = function (ids) {\r\n        var _this = this;\r\n        if (ids === void 0) { ids = []; }\r\n        this.getProcessIds(ids).forEach(function (id) {\r\n            var waveShaper = _this.getTrack(id);\r\n            if (waveShaper != null)\r\n                waveShaper.flatten();\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Processes all relevant WaveShapers and invokes registered callbacks\r\n     *\r\n     * @param ids Options array of id's to draw\r\n     * @param start Start position\r\n     * @param width Width to process\r\n     * @param shift Units to shift current data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.process = function (ids, start, width, shift) {\r\n        if (ids === void 0) { ids = []; }\r\n        if (start === void 0) { start = 0; }\r\n        if (width === void 0) { width = this.options.width; }\r\n        if (shift === void 0) { shift = 0; }\r\n        var toProcess = this.getProcessIds(ids);\r\n        var options = __assign({}, this.options);\r\n        var data = [];\r\n        for (var i = 0; i < toProcess.length; i++) {\r\n            var id = toProcess[i];\r\n            var wave = this.getTrack(id);\r\n            if (wave == null)\r\n                continue;\r\n            var peaks = wave.calculate(options, this.audioData, start, width, shift);\r\n            data.push({ id: id, data: peaks });\r\n        }\r\n        // Invoke callbacks after returning value.\r\n        this._lastProcessResult = { options: options, data: data };\r\n        this.invokeCallbacks(this._lastProcessResult, start, width, shift);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a callback that fires when the track with given id is processed\r\n     *\r\n     * @param id id of Track to register to\r\n     * @param callBack will be invoked when the given track is processed\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.on = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null) {\r\n            this.callbackMap.set(id, [callBack]);\r\n        }\r\n        else {\r\n            callbackArray.push(callBack);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters a callback from the given track, will no longer be called\r\n     *\r\n     * @param id id of Track to unregister from\r\n     * @param callBack callback to remove\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.off = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return this;\r\n        var index = callbackArray.indexOf(callBack);\r\n        if (index < 0)\r\n            return this;\r\n        callbackArray = callbackArray.splice(index, 1);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a callback that is triggered when an Interval is updated\r\n     *\r\n     * @param cb Callback function\r\n     */\r\n    WaveShaper.prototype.onSegment = function (cb) {\r\n        this.segmentCallbackMap.push(cb);\r\n    };\r\n    /**\r\n     * Removes a previously added callback for the Interval update callback\r\n     *\r\n     * @param cb Callback function\r\n     */\r\n    WaveShaper.prototype.offSegment = function (cb) {\r\n        var index = this.segmentCallbackMap.indexOf(cb);\r\n        if (index !== -1) {\r\n            this.segmentCallbackMap.splice(index, 1);\r\n        }\r\n    };\r\n    /**\r\n     * Emits a segment update\r\n     *\r\n     * @param old Old interval\r\n     * @param changed Updated interval\r\n     */\r\n    WaveShaper.prototype.emitSegment = function (old, changed) {\r\n        this.segmentCallbackMap.forEach(function (cb) { return cb(old, changed); });\r\n    };\r\n    /**\r\n     * Adds a callback that is fired when options are updated\r\n     *\r\n     * @param cb Callback function\r\n     */\r\n    WaveShaper.prototype.onOptions = function (cb) {\r\n        this.optionsCallbacks.push(cb);\r\n    };\r\n    /**\r\n     * Removes a previously added callback\r\n     * @param cb Callback function\r\n     */\r\n    WaveShaper.prototype.offOptions = function (cb) {\r\n        var index = this.optionsCallbacks.indexOf(cb);\r\n        if (index !== -1) {\r\n            this.optionsCallbacks.splice(index, 1);\r\n        }\r\n    };\r\n    /**\r\n     * Emits an options update\r\n     *\r\n     * @param old Old options\r\n     * @param updated New options\r\n     */\r\n    WaveShaper.prototype.emitOptions = function (old, updated) {\r\n        this.optionsCallbacks.forEach(function (cb) { return cb(old, updated); });\r\n    };\r\n    /**\r\n     * @description Merges the given options into the current and returns updated options\r\n     *\r\n     * @param options A (partial) ManagerOptions object\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setOptions = function (options) {\r\n        this.validateOptions(options);\r\n        var oldOptions = __assign({}, this.options);\r\n        this._options = __assign({}, oldOptions, options);\r\n        this.emitOptions(oldOptions, this.options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     *\r\n     * @param id id of WaveShaper\r\n     * @param segments Segments in wave\r\n     * @param color Background color of segments\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setTracks = function () {\r\n        var tracks = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tracks[_i] = arguments[_i];\r\n        }\r\n        for (var i = 0; i < tracks.length; i++) {\r\n            var track = tracks[i];\r\n            var foundWave = this.getTrack(track.id);\r\n            if (foundWave == null) {\r\n                var wave = new track_1.default(track.id, track.intervals, this._options.width);\r\n                this.tracks.set(track.id, wave);\r\n            }\r\n            else {\r\n                foundWave.intervals = track.intervals || [];\r\n                foundWave.flatten();\r\n            }\r\n        }\r\n        this._duration = this.getDuration();\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds audio data to the waveshaper and redraws waveshapers using it\r\n     *\r\n     * @param id  Data id, refered to by source parameter of segments\r\n     * @param data AudioBuffer with audio data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setData = function () {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            data[_i] = arguments[_i];\r\n        }\r\n        data.forEach(function (d) {\r\n            _this.audioData.set(d.id, d.data);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description The given id's are set as the active waveshapers, process only processes these when set,\r\n     * call with no values to allways process all values (default)\r\n     *\r\n     * @param ids Waveshaper id's to set as active\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setActive = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this._activeWaveShapers = ids;\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Removes the waves and all callbacks with given id from the manager\r\n     *\r\n     * @param id\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.clearTracks = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        ids.forEach(function (id) {\r\n            _this.removeCallbacksById(id);\r\n            _this.tracks.delete(id);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Gets Track with given id\r\n     *\r\n     * @param id\r\n     * @returns Track with given ID\r\n     */\r\n    WaveShaper.prototype.getTrack = function (id) {\r\n        return this.tracks.get(id);\r\n    };\r\n    /**\r\n     * Validates given options\r\n     *\r\n     * @param options\r\n     * @returns true if valid, false if not\r\n     */\r\n    WaveShaper.prototype.validateOptions = function (options) {\r\n        var currentOptions = this._options || managerconfig_1.default;\r\n        if (!options.samplesPerPixel || options.samplesPerPixel <= 0) {\r\n            options.samplesPerPixel = currentOptions.samplesPerPixel;\r\n        }\r\n        if (!options.meterType) {\r\n            options.meterType = currentOptions.meterType;\r\n        }\r\n        if (!options.resolution || options.resolution <= 0) {\r\n            options.resolution = currentOptions.resolution;\r\n        }\r\n        if (!options.width || this.options.width <= 0) {\r\n            options.width = currentOptions.width;\r\n        }\r\n        if (!options.scrollPosition || this.options.scrollPosition <= 0) {\r\n            options.scrollPosition = currentOptions.scrollPosition;\r\n        }\r\n        if (!options.samplerate || this.options.samplerate <= 0) {\r\n            options.samplerate = currentOptions.samplerate;\r\n        }\r\n    };\r\n    /**\r\n     * Invokes all registered callbacks registered to a waveshaper id in the data list\r\n     *\r\n     * @param options\r\n     * @param data\r\n     */\r\n    WaveShaper.prototype.invokeCallbacks = function (result, start, width, shift) {\r\n        for (var i = 0; i < result.data.length; i++) {\r\n            var trackResult = result.data[i];\r\n            var callbacks = this.callbackMap.get(trackResult.id);\r\n            if (callbacks == null)\r\n                continue;\r\n            for (var j = 0; j < callbacks.length; j++) {\r\n                var callback = callbacks[j];\r\n                callback(result.options, new Float32Array(trackResult.data), start, width, shift);\r\n            }\r\n        }\r\n    };\r\n    WaveShaper.prototype.getProcessIds = function (ids) {\r\n        if (ids.length > 0)\r\n            return ids;\r\n        if (this._activeWaveShapers.length > 0)\r\n            return this._activeWaveShapers;\r\n        return Array.from(this.tracks.keys());\r\n    };\r\n    WaveShaper.prototype.removeCallbacksById = function (id) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return;\r\n        callbackArray.splice(0, callbackArray.length);\r\n        this.callbackMap.delete(id);\r\n    };\r\n    /**\r\n     * @description Returns the maximum duration of all the waveshapers managed by this class\r\n     *\r\n     * @returns Maximum duration in seconds\r\n     * @memberof WaveShaper\r\n     */\r\n    WaveShaper.prototype.getDuration = function () {\r\n        return Array.from(this.tracks.values()).reduce(function (maxDuration, waveShaper) {\r\n            var duration = waveShaper.getDuration();\r\n            return duration > maxDuration ? duration : maxDuration;\r\n        }, 0);\r\n    };\r\n    return WaveShaper;\r\n}());\r\nexports.default = WaveShaper;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.intervalMerge = {})));\n}(this, (function (exports) { 'use strict';\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\r\n   * @typedef {Object} Interval\r\n   * \r\n   * @property {number} start\r\n   * @property {number} offsetStart\r\n   * @property {number} end\r\n   * @property {number} index\r\n   */\n\n  /**\r\n   * @typedef {{[key: string]: Interval}} IntervalMap\r\n   */\n\n  /**\r\n   * @param {Interval} interval\r\n   */\n  var calcStart = function calcStart(interval) {\n    return interval.start + interval.offsetStart;\n  };\n\n  /**\r\n   * The algorithm first calculates real start and end times of each segment,\r\n   * sorts them by priority, then start time.\r\n   *\r\n   * Finally it merges the segments by index so there are no overlapping\r\n   * segments and those with highest index are on top.\r\n   *\r\n   * @export\r\n   * @param {Interval[]} intervals Segments to flatten\r\n   * @returns {Interval[]} flattened Interval array\r\n   */\n  var weightedIntervalMerge = function weightedIntervalMerge(intervals) {\n    if (intervals == null || intervals.length === 0) return [];\n\n    var sorted = sort(intervals);\n    var normalized = normalizeIndex(sorted);\n    var copied = copy(normalized);\n    var grouped = groupByIndex(copied);\n\n    return weightedMerge(grouped);\n  };\n\n  /**\r\n   * Copies elements so original are unaltered\r\n   * \r\n   * @param {Interval[]} intervals \r\n   */\n  var copy = function copy(intervals) {\n    return intervals.map(function (i) {\n      return _extends({}, i, {\n        offsetStart: i.offsetStart || 0,\n        index: i.index || 1\n      });\n    });\n  };\n\n  /**\r\n   * When an element is altered the index is set very high,\r\n   * this functions normalizes to indexes back to 0\r\n   * \r\n   * @param {Intervalp[]} intervals \r\n   */\n  var normalizeIndex = function normalizeIndex(intervals) {\n    var index = 0;\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\n    intervals.forEach(function (el) {\n      if (el.index > preNormalizeIndex) {\n        preNormalizeIndex = el.index;\n        el.index = ++index;\n      } else {\n        el.index = index;\n      }\n    });\n    return intervals;\n  };\n\n  /**\r\n   * Sorts the intervals by index, then by start\r\n   * \r\n   * @param {Interval[]} intervals \r\n   * @return {Interval[]} Interval array\r\n   */\n  var sort = function sort(intervals) {\n    return intervals.sort(function (a, b) {\n      return cmp(a.index, b.index) || cmp(calcStart(a), calcStart(b));\n    });\n  };\n\n  /**\r\n   * Returns a map of intervals grouped by the key property\r\n   * \r\n   * @param {Interval[]} intervals \r\n   * @returns {IntervalMap} Map of index => interval[]\r\n   */\n  var groupByIndex = function groupByIndex(intervals) {\n    return intervals.reduce(function (groups, interval) {\n      (groups[interval.index] = groups[interval.index] || []).push(interval);\n      return groups;\n    }, {});\n  };\n\n  /**\r\n   * Merges all the groups by index\r\n   * \r\n   * @param {IntervalMap} grouped \r\n   * @returns {Interval[]} Interval array\r\n   */\n  var weightedMerge = function weightedMerge(grouped) {\n    var flattened = null;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.keys(grouped)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var index = _step.value;\n\n        var merged = merge(grouped[index]);\n        if (flattened == null) {\n          flattened = merged;\n        } else {\n          flattened = combine(merged, flattened);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return flattened;\n  };\n\n  /**\r\n   * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n   * \r\n   * @param {Interval[]} intervals \r\n   * @returns {Interval[]} Interval array\r\n   */\n  var merge = function merge(intervals) {\n    if (intervals.length <= 1) return intervals;\n\n    var result = [];\n\n    var current = intervals[0];\n    for (var i = 1; i < intervals.length; i++) {\n      var next = intervals[i];\n\n      // If current is completely overlapped by second it is merged into it\n      if (current.end >= next.end) {\n        continue;\n        // Resolves partial overlaps by setting end of current to start of next\n      } else if (calcStart(next) < current.end) {\n        result.push(_extends({}, current, { end: calcStart(next) }));\n        current = next;\n      } else {\n        // No overlap, push onto results\n        result.push(current);\n        current = next;\n      }\n    }\n\n    result.push(current);\n    return result;\n  };\n\n  /**\r\n   * Given two sets of intervals it merges them so the highIndexes set has priority\r\n   *\r\n   * @param {Interval[]} highIndexes\r\n   * @param {Interval[]} lowIndexes\r\n   * \r\n   * @returns {Interval[]} Interval array\r\n   */\n  var combine = function combine(highIndexes, lowIndexes) {\n    var highIndex = 0;\n    var lowIndex = 0;\n\n    var merged = [];\n\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\n\n      var high = highIndexes[highIndex];\n      var low = lowIndexes[lowIndex];\n\n      // Only low priority left so push low onto results\n      if (highIndex === highIndexes.length) {\n        merged.push(_extends({}, low));\n        lowIndex++;\n        // Only high priority left so push high onto results\n      } else if (lowIndex === lowIndexes.length) {\n        merged.push(_extends({}, high));\n        highIndex++;\n        // High priority start before or at same time as low\n      } else if (calcStart(high) <= calcStart(low)) {\n        // No overlap between low and high\n        // low:                 ----------------------\n        // high: ---------------\n        if (high.end <= calcStart(low)) ; else if (high.end < low.end) {\n          low.offsetStart = high.end - low.start;\n          // Low index completely overlapped, dismiss it\n          // low:               -----------\n          // high: -------------------------------------\n        } else {\n          lowIndex++;\n        }\n\n        merged.push(_extends({}, high));\n        highIndex++;\n        // Low priority starts before high\n      } else {\n        // No overlap between low and high intervals\n        // low: ---------------\n        // high                ----------------------\n        if (low.end <= calcStart(high)) {\n          merged.push(_extends({}, low));\n          lowIndex++;\n          // Partial overlap where high ends after low\n          // low: ---------------------\n          // high                ----------------------\n        } else if (high.end > low.end) {\n          merged.push(_extends({}, low, { end: calcStart(high) }));\n          lowIndex++;\n          // Partial overlap where high ends before low\n          // low: -------------------------------------\n          // high             -----------\n        } else {\n          merged.push(_extends({}, low, { end: calcStart(high) }));\n          low.offsetStart = high.end - low.start;\n        }\n      }\n    }\n\n    return merged;\n  };\n\n  /**\r\n   *\r\n   * @param {number} a\r\n   * @param {number} b\r\n   */\n  var cmp = function cmp(a, b) {\n    if (a > b) return +1;\n    if (a < b) return -1;\n    return 0;\n  };\n\n  exports.weightedIntervalMerge = weightedIntervalMerge;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar start = function (segment) { return segment.start + segment.offsetStart; };\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param segments Segments to flatten\r\n * @returns flattened Interval array\r\n */\r\nexports.default = (function (segments) {\r\n    if (segments == null || segments.length === 0)\r\n        return [];\r\n    var sorted = sort(segments);\r\n    var normalized = normalizeIndex(sorted);\r\n    var copied = copy(normalized);\r\n    var grouped = groupByIndex(copied);\r\n    return weightedMerge(grouped);\r\n});\r\n/**\r\n * Copies elements so original are unaltered\r\n *\r\n * @param intervals\r\n */\r\nvar copy = function (intervals) {\r\n    return intervals.map(function (i) { return (__assign({}, i)); });\r\n};\r\n/**\r\n * When an element is altered the index is set very high,\r\n * this functions normalizes to indexes back to 0\r\n *\r\n * @param segments\r\n */\r\nvar normalizeIndex = function (segments) {\r\n    var index = 0;\r\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\r\n    segments.forEach(function (el) {\r\n        if (el.index > preNormalizeIndex) {\r\n            preNormalizeIndex = el.index;\r\n            el.index = ++index;\r\n        }\r\n        else {\r\n            el.index = index;\r\n        }\r\n    });\r\n    return segments;\r\n};\r\n/**\r\n * Sorts the intervals by index, then by start\r\n *\r\n * @param intervals\r\n * @return Interval array\r\n */\r\nvar sort = function (intervals) {\r\n    return intervals.sort(function (a, b) { return cmp(a.index, b.index) || cmp(start(a), start(b)); });\r\n};\r\n/**\r\n * Returns a map of intervals grouped by the key property\r\n *\r\n * @param intervals\r\n * @param key\r\n *\r\n * @returns Map of index => interval[]\r\n */\r\nvar groupByIndex = function (intervals) {\r\n    return intervals.reduce(function (groups, interval) {\r\n        (groups[interval.index] = groups[interval.index] || []).push(interval);\r\n        return groups;\r\n    }, {});\r\n};\r\n/**\r\n * Merges all the groups by index\r\n *\r\n * @param grouped\r\n * @returns Interval array\r\n */\r\nvar weightedMerge = function (grouped) {\r\n    var flattened = null;\r\n    for (var _i = 0, _a = Object.keys(grouped); _i < _a.length; _i++) {\r\n        var index = _a[_i];\r\n        var merged = merge(grouped[index]);\r\n        if (flattened == null) {\r\n            flattened = merged;\r\n        }\r\n        else {\r\n            flattened = combine(merged, flattened);\r\n        }\r\n    }\r\n    return flattened;\r\n};\r\n/**\r\n * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n *\r\n * @param intervals\r\n * @returns Interval array\r\n */\r\nvar merge = function (intervals) {\r\n    if (intervals.length <= 1)\r\n        return intervals;\r\n    var result = [];\r\n    var current = intervals[0];\r\n    for (var i = 1; i < intervals.length; i++) {\r\n        var next = intervals[i];\r\n        // If current is completely overlapped by second it is merged into it\r\n        if (current.end >= next.end) {\r\n            continue;\r\n            // Resolves partial overlaps by setting end of current to start of next\r\n        }\r\n        else if (start(next) < current.end) {\r\n            result.push(__assign({}, current, { end: start(next) }));\r\n            current = next;\r\n        }\r\n        else {\r\n            // No overlap, push onto results\r\n            result.push(current);\r\n            current = next;\r\n        }\r\n    }\r\n    result.push(current);\r\n    return result;\r\n};\r\n/**\r\n * Given two sets of intervals it merges them so the highIndexes set has priority\r\n *\r\n * @param highIndexes\r\n * @param lowIndexes\r\n *\r\n * @returns Interval array\r\n */\r\nvar combine = function (highIndexes, lowIndexes) {\r\n    var highIndex = 0;\r\n    var lowIndex = 0;\r\n    var merged = [];\r\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\r\n        var high = highIndexes[highIndex];\r\n        var low = lowIndexes[lowIndex];\r\n        // Only low priority left so push low onto results\r\n        if (highIndex === highIndexes.length) {\r\n            merged.push(__assign({}, low));\r\n            lowIndex++;\r\n            // Only high priority left so push high onto results\r\n        }\r\n        else if (lowIndex === lowIndexes.length) {\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // High priority start before or at same time as low\r\n        }\r\n        else if (start(high) <= start(low)) {\r\n            // No overlap between low and high\r\n            // low:                 ----------------------\r\n            // high: ---------------\r\n            if (high.end <= start(low)) {\r\n                // Partial overlap where high ends after low\r\n                // low:                 ----------------------\r\n                // high: ----------------------\r\n            }\r\n            else if (high.end < low.end) {\r\n                low.offsetStart = high.end - low.start;\r\n                // Low index completely overlapped, dismiss it\r\n                // low:               -----------\r\n                // high: -------------------------------------\r\n            }\r\n            else {\r\n                lowIndex++;\r\n            }\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // Low priority starts before high\r\n        }\r\n        else {\r\n            // No overlap between low and high intervals\r\n            // low: ---------------\r\n            // high                ----------------------\r\n            if (low.end <= start(high)) {\r\n                merged.push(__assign({}, low));\r\n                lowIndex++;\r\n                // Partial overlap where high ends after low\r\n                // low: ---------------------\r\n                // high                ----------------------\r\n            }\r\n            else if (high.end > low.end) {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                lowIndex++;\r\n                // Partial overlap where high ends before low\r\n                // low: -------------------------------------\r\n                // high             -----------\r\n            }\r\n            else {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                low.offsetStart = high.end - low.start;\r\n            }\r\n        }\r\n    }\r\n    return merged;\r\n};\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nvar cmp = function (a, b) {\r\n    if (a > b)\r\n        return +1;\r\n    if (a < b)\r\n        return -1;\r\n    return 0;\r\n};\r\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=waveshaper.js.map","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","import DomRenderWaveShaper from './core/domrender-waveshaper';\r\n\r\nexport {\r\n    DomRenderWaveShaper\r\n}\r\n\r\nexport default new DomRenderWaveShaper();","import { WaveShaper, AudioInterval } from \"waveshaper\";\r\nimport * as Hammer from \"hammerjs\";\r\n\r\nimport hammerConfig from \"../config/hammerconfig\";\r\nimport cut from \"../interactions/cut\";\r\nimport drag from \"../interactions/drag\";\r\nimport pan from \"../interactions/pan\";\r\nimport zoom from \"../interactions/zoom\";\r\nimport resize from \"../interactions/resize\";\r\nimport line from \"../render/line\";\r\nimport enter from \"../interactions/enter\";\r\nimport defaultDomOptions, { DomInput, DomOptions } from \"../config/dom-config\";\r\nimport { dragState } from \"../models/dragstate\";\r\n\r\n/**\r\n * Extends WaveShapeManager to allow for easy canvas rendering registration.\r\n *\r\n * @inheritDoc\r\n */\r\nexport default class DomRenderWaveShaper extends WaveShaper {\r\n  private unregister = () => {};\r\n\r\n  private unregisterMap = new Map<string, () => void>();\r\n  private canvasMap = new Map<string, () => void>();\r\n\r\n  public get scrollWidth(): number {\r\n    return (\r\n      (this._duration * this._options.samplerate) /\r\n      this._options.samplesPerPixel\r\n    );\r\n  }\r\n\r\n  public get options(): DomOptions {\r\n    return { ...this._options };\r\n  }\r\n  protected _options: DomOptions;\r\n\r\n  public get hammer(): HammerManager | null {\r\n    return this._hammer;\r\n  }\r\n  protected _hammer: HammerManager | null;\r\n\r\n  protected cutCallbacks: ((\r\n    original: AudioInterval,\r\n    left: AudioInterval,\r\n    right: AudioInterval\r\n  ) => void)[] = [];\r\n\r\n  constructor(options: DomInput = defaultDomOptions) {\r\n    super(options);\r\n\r\n    this._options = { ...defaultDomOptions, ...this._options };\r\n  }\r\n\r\n  setOptions(input: DomInput) {\r\n    const oldOptions = { ...this.options };\r\n    this._options = { ...oldOptions, ...input };\r\n\r\n    this.emitOptions(oldOptions, this.options);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @description When a canvas is registered through this method each time the\r\n   * waveform is updated the canvas will be rerendered.\r\n   *\r\n   * It returns an unregister method, call to stop receiving callbacks.\r\n   *\r\n   * @param id WaveShaper id to register to.\r\n   * @param canvas Canvas to render to\r\n   * @param color Background color of segments\r\n   */\r\n  registerCanvas(\r\n    id: string,\r\n    canvas: HTMLCanvasElement,\r\n    color: string\r\n  ): DomRenderWaveShaper {\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (ctx == null) throw Error(\"Cannot get context from canvas.\");\r\n\r\n    // Add classes and data attributes\r\n    canvas.classList.add(\"waveshaper\");\r\n    canvas.setAttribute(\"data-wave-id\", id);\r\n\r\n    canvas.style.width = this.options.width + \"px\";\r\n    canvas.style.height = this.options.height + \"px\";\r\n\r\n    const scale = (devicePixelRatio || 1) < 1 ? 1 : devicePixelRatio || 1;\r\n\r\n    canvas.width = this.options.width * scale;\r\n    canvas.height = this.options.height;\r\n\r\n    ctx.scale(scale, 1);\r\n\r\n    const callBack = (options: DomOptions, data: Float32Array) =>\r\n      line(data, options, ctx, color);\r\n    this.on(id, callBack);\r\n\r\n    this.unregisterCanvas(id);\r\n\r\n    this.canvasMap.set(id, () => this.off(id, callBack));\r\n\r\n    const unregister = enter(this, canvas, dragState);\r\n    this.unregisterMap.set(id, unregister);\r\n\r\n    // If registerSetsActive is true\r\n    if (this._options.registerSetsActive) {\r\n      this.setActive(...this.activeWaveShapers.concat(id));\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clears the callbacks associated with this canvas\r\n   *\r\n   * @param id\r\n   * @returns Instance of WaveShaper\r\n   */\r\n  unregisterCanvas(id: string): DomRenderWaveShaper {\r\n    const unregister = this.canvasMap.get(id);\r\n    if (unregister != null) {\r\n      unregister();\r\n      this.canvasMap.delete(id);\r\n    }\r\n\r\n    const unregisterEvents = this.unregisterMap.get(id);\r\n    if (unregisterEvents != null) {\r\n      unregisterEvents();\r\n      this.unregisterMap.delete(id);\r\n    }\r\n\r\n    if (this._options.registerSetsActive) {\r\n      const index = this.activeWaveShapers.indexOf(id);\r\n      if (index != -1) {\r\n        this.setActive(\r\n          ...this.activeWaveShapers.filter(trackId => trackId !== id)\r\n        );\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  emitCut(original: AudioInterval, left: AudioInterval, right: AudioInterval) {\r\n    this.cutCallbacks.forEach(cb => cb(original, left, right));\r\n  }\r\n\r\n  onCut(\r\n    cb: (\r\n      original: AudioInterval,\r\n      left: AudioInterval,\r\n      right: AudioInterval\r\n    ) => void\r\n  ) {\r\n    this.cutCallbacks.push(cb);\r\n  }\r\n\r\n  /**\r\n   * Loads and saves a set of url's to audio files.\r\n   *\r\n   * @param ctx\r\n   * @param data\r\n   */\r\n  loadData(\r\n    ctx: AudioContext,\r\n    ...data: { id: string; url: string }[]\r\n  ): DomRenderWaveShaper {\r\n    data.forEach(dat => {\r\n      fetch(dat.url)\r\n        .then(res => res.arrayBuffer())\r\n        .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))\r\n        .then(audioBuffer => {\r\n          this.setData({\r\n            id: dat.id,\r\n            data: audioBuffer.getChannelData(0)\r\n          }).process();\r\n        })\r\n        .catch(e => console.log(e));\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  setInteraction(element: HTMLElement) {\r\n    if (element == null)\r\n      throw Error(\"Interaction container element could not be found.\");\r\n    this.unregister();\r\n\r\n    element.setAttribute(\"touch-action\", \"none\");\r\n\r\n    const hammer = new Hammer(element, hammerConfig);\r\n    this._hammer = hammer;\r\n\r\n    drag(this, hammer, dragState);\r\n    cut(this, hammer);\r\n    pan(this, hammer);\r\n    zoom(this, hammer);\r\n    resize(this, hammer);\r\n\r\n    this.unregister = () => {\r\n      hammer.destroy();\r\n    };\r\n\r\n    return this;\r\n  }\r\n\r\n  clearInteraction() {\r\n    this.unregister();\r\n    this.unregister = () => {};\r\n\r\n    this._hammer = null;\r\n  }\r\n}\r\n","import * as Hammer from 'hammerjs';\r\n\r\nconst hammerOptions: HammerOptions = {\r\n    touchAction : 'pan-y',\r\n    recognizers: [\r\n        [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }],\r\n        [Hammer.Pinch, { enable : true }],\r\n        [Hammer.Tap]\r\n    ]\r\n}\r\n\r\nexport default hammerOptions;","import { AudioInterval } from \"waveshaper\";\r\nimport DomRenderWaveShaper from \"../core/domrender-waveshaper\";\r\nimport { DomOptions } from \"../config/dom-config\";\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager) => {\r\n  const shouldHandle = (target: HTMLElement, options: DomOptions) =>\r\n    options.mode === \"cut\" && target.hasAttribute(\"data-wave-id\");\r\n\r\n  hammer.on(\"tap\", (ev: HammerInput) => {\r\n    const options = manager.options;\r\n    const target = manager.options.getEventTarget(ev.srcEvent);\r\n    if (options == null || !shouldHandle(target, options)) return;\r\n\r\n    // Allready checked for null\r\n    const id = <string>target.getAttribute(\"data-wave-id\");\r\n\r\n    const wave = manager.getTrack(id);\r\n    if (wave == null) return;\r\n\r\n    const bb = target.getBoundingClientRect();\r\n    const deltaX = ev.center.x - bb.left;\r\n    let time =\r\n      (options.scrollPosition + deltaX) *\r\n      (options.samplesPerPixel / options.samplerate);\r\n\r\n    time = options.clampFn(time);\r\n\r\n    const interval = wave.flattened.find(\r\n      i => i.start + i.offsetStart <= time && i.end >= time\r\n    );\r\n    if (interval == null) return;\r\n\r\n    const left = wave.intervals.find(s => s.id === interval.id);\r\n    if (left == null) return;\r\n\r\n    const original = { ...left };\r\n\r\n    const right: AudioInterval = {\r\n      ...left,\r\n      offsetStart: time - left.start,\r\n      id: options.generateId()\r\n    };\r\n\r\n    left.end = time;\r\n    wave.intervals.push(right);\r\n\r\n    manager.flatten([wave.id]);\r\n    manager.process([wave.id], deltaX, 1);\r\n\r\n    manager.emitCut({ ...original }, { ...left }, { ...right });\r\n  });\r\n};\r\n","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\nimport { DragState } from '../models/dragstate';\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager Waveshape Manager\r\n * @param hammer Hammer instance\r\n * @param container Container element\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager, dragState: DragState) => {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'drag' && target.hasAttribute('data-wave-id');\r\n\r\n    /**\r\n     * Sets up the drag by finding the \r\n     */\r\n    hammer.on('panstart', (ev: HammerInput) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n\r\n        // Allready checked for existance\r\n        const id = <string>target.getAttribute('data-wave-id');\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n\r\n        if (interval == null)\r\n            return;\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        dragState.startState = { ...segment };\r\n\r\n        if(ev.srcEvent instanceof PointerEvent) { \r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n\r\n        dragState.options = options;\r\n\r\n        dragState.activeSegment = segment;\r\n        dragState.activeSegmentStart = dragState.activeSegment.start;\r\n        dragState.duration = segment.end - segment.start;\r\n\r\n        dragState.activeSegment.index = 1000;\r\n        dragState.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('panmove', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || dragState.activeSegment == null || dragState.dragWave == null \r\n            || dragState.dragging || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        dragState.dragging = true;\r\n\r\n        /** \r\n         * TODO below implementation stops all updates on touch devices on new track (tested on Samsung Galaxy s8),\r\n         * when dragged back to original keeps working. Works on desktop, it's a small performance improvement as\r\n         * it prevents a single track flatten + process when transferring a segment between tracks.\r\n         */\r\n\r\n        //// If the target has moved it is handled by the mouseHover function\r\n        // const id = ev.target.getAttribute('data-wave-id');\r\n        // if(id !== dragState.dragWave.id)\r\n        //     return;\r\n\r\n        const change = (ev.deltaX * dragState.options.samplesPerPixel) / dragState.options.samplerate;\r\n        let newTime = dragState.activeSegmentStart + change;\r\n\r\n        newTime = manager.options.clampFn(newTime);\r\n\r\n        if (newTime + dragState.activeSegment.offsetStart < 0) {\r\n            newTime = -dragState.activeSegment.offsetStart;\r\n        }\r\n\r\n        dragState.activeSegment.start = newTime;\r\n        dragState.activeSegment.end = newTime + dragState.duration;\r\n\r\n        manager.flatten([dragState.dragWave.id]);\r\n        manager.process([dragState.dragWave.id]);\r\n\r\n        dragState.dragging = false;\r\n    });\r\n\r\n    hammer.on('panend', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        if(dragState.startState != null && dragState.activeSegment != null) \r\n            manager.emitSegment(dragState.startState, { ...dragState.activeSegment });\r\n\r\n        dragState.activeSegment = null;\r\n        dragState.activeSegmentStart = 0;\r\n        dragState.dragWave = null;\r\n        dragState.options = null;\r\n        dragState.duration = 0;\r\n        dragState.startState = null;\r\n    });\r\n}","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface PanState {\r\n    panStart: number;\r\n    panMax: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst panState: PanState = {\r\n    panStart: 0,\r\n    panMax: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pan functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        if(ev.srcEvent instanceof PointerEvent) { \r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n\r\n        panState.panMax = manager.scrollWidth + endMargin;\r\n        panState.panStart = options.scrollPosition;\r\n    });\r\n\r\n    hammer.on('panmove', (ev) =>  {\r\n        panState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n\r\n        if(!shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        const position = panState.panStart - ev.deltaX;\r\n        const newPosition = Math.floor(position > 0 ? position : 0);\r\n        const change = newPosition - panState.options.scrollPosition;\r\n\r\n        // If it was and is still 0 no need to update\r\n        if(newPosition === panState.options.scrollPosition)\r\n            return;\r\n\r\n        if(newPosition > panState.panMax - panState.options.width)\r\n            return;\r\n        \r\n        const start = change > 0 ? panState.options.width - change : 0;\r\n        const width = Math.abs(change);\r\n        \r\n        manager.setOptions({ scrollPosition: newPosition }).process(undefined, start, width, change);\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(panState.options == null || !shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        panState.options = null;\r\n        panState.panStart = 0;\r\n        panState.panMax = 0;\r\n    });\r\n}","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface ZoomState {\r\n    maxWidth: number;\r\n    sppStart: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst zoomState: ZoomState = {\r\n    maxWidth: 0,\r\n    sppStart: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pinch zoom functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('pinchstart', (ev) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        if(ev.srcEvent instanceof PointerEvent) { \r\n            target.setPointerCapture(ev.srcEvent.pointerId);\r\n        }\r\n\r\n        zoomState.sppStart = options.samplesPerPixel;\r\n        zoomState.maxWidth = manager.scrollWidth + endMargin;\r\n    });\r\n\r\n    hammer.on('pinchmove', (ev) => {\r\n        zoomState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options) || ev.scale == null || ev.scale <= 0)\r\n            return;\r\n\r\n        const sampleAtLeft = zoomState.options.scrollPosition * zoomState.options.samplesPerPixel;\r\n        const samplesInView = zoomState.options.width * zoomState.options.samplesPerPixel;\r\n        const samplesToCenter = samplesInView / 2;\r\n\r\n        const newSpp = zoomState.sppStart * ev.scale;\r\n        if(newSpp == 0) return;\r\n\r\n        const newSamplesInView = zoomState.options.width * newSpp;\r\n        const newSamplesToCenter = newSamplesInView / 2;\r\n\r\n        const maxWidth = manager.scrollWidth + endMargin;\r\n        const maxSamplesInView = maxWidth  * zoomState.options.samplerate;\r\n\r\n        if(newSamplesInView >= maxSamplesInView)\r\n            return;\r\n\r\n        const newScroll = (sampleAtLeft + samplesToCenter - newSamplesToCenter) / newSpp;\r\n\r\n        manager.setOptions({\r\n            samplesPerPixel: newSpp,\r\n            scrollPosition: newScroll >= 0 ? newScroll : 0\r\n        }).process();\r\n    });\r\n\r\n    hammer.on('pinchend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n\r\n        zoomState.sppStart = 0;\r\n        zoomState.maxWidth = 0;\r\n        zoomState.options = null;\r\n    });\r\n}","import { AudioInterval, Track } from \"waveshaper\";\r\nimport DomRenderWaveShaper from \"../core/domrender-waveshaper\";\r\nimport { DomOptions } from \"../config/dom-config\";\r\n\r\ndeclare type SegmentSide = \"left\" | \"right\";\r\n\r\ninterface ResizeState {\r\n  activeSegment: AudioInterval | null;\r\n  activeSegmentSide: SegmentSide | null;\r\n  activeSegmentOffsetStart: number;\r\n  activeSegmentOffsetEnd: number;\r\n  dragWave: Track | null;\r\n  options: DomOptions | null;\r\n  startState: AudioInterval | null;\r\n}\r\n\r\nconst resizeState: ResizeState = {\r\n  activeSegment: null,\r\n  activeSegmentSide: null,\r\n  activeSegmentOffsetStart: 0,\r\n  activeSegmentOffsetEnd: 0,\r\n  dragWave: null,\r\n  options: null,\r\n  startState: null\r\n};\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n  const shouldHandle = (target: HTMLElement, options: DomOptions) =>\r\n    options.mode === \"resize\" &&\r\n    target != null &&\r\n    target.hasAttribute(\"data-wave-id\");\r\n\r\n  hammer.on(\"panstart\", ev => {\r\n    const options = manager.options;\r\n    const target = manager.options.getEventTarget(ev.srcEvent);\r\n\r\n    if (!shouldHandle(target, options)) return;\r\n\r\n    // Already checked that it exists\r\n    const id = <string>target.getAttribute(\"data-wave-id\");\r\n\r\n    const wave = manager.getTrack(id);\r\n    if (wave == null) return;\r\n\r\n    const bb = target.getBoundingClientRect();\r\n    const time =\r\n      ((options.scrollPosition + (ev.center.x - bb.left)) *\r\n        options.samplesPerPixel) /\r\n      options.samplerate;\r\n\r\n    const interval = wave.flattened.find(\r\n      i => i.start + i.offsetStart <= time && i.end >= time\r\n    );\r\n\r\n    if (interval == null) return;\r\n\r\n    resizeState.activeSegmentSide =\r\n      time <\r\n      interval.start +\r\n        interval.offsetStart +\r\n        (interval.end - (interval.start + interval.offsetStart)) / 2\r\n        ? \"left\"\r\n        : \"right\";\r\n\r\n    const segment = wave.intervals.find(s => s.id === interval.id);\r\n    if (segment == null) return;\r\n\r\n    resizeState.startState = { ...segment };\r\n\r\n    if (ev.srcEvent instanceof PointerEvent) {\r\n      target.setPointerCapture(ev.srcEvent.pointerId);\r\n    }\r\n\r\n    resizeState.options = options;\r\n    resizeState.activeSegment = segment;\r\n\r\n    resizeState.activeSegmentOffsetStart = segment.offsetStart;\r\n    resizeState.activeSegmentOffsetEnd = segment.end;\r\n\r\n    segment.index = 1000;\r\n    resizeState.dragWave = wave;\r\n  });\r\n\r\n  hammer.on(\"panmove\", ev => {\r\n    const target = manager.options.getEventTarget(ev.srcEvent);\r\n    if (\r\n      resizeState.dragWave == null ||\r\n      resizeState.activeSegment == null ||\r\n      resizeState.options == null ||\r\n      !shouldHandle(target, resizeState.options)\r\n    )\r\n      return;\r\n\r\n    const options = manager.options;\r\n\r\n    const change = (ev.deltaX * options.samplesPerPixel) / options.samplerate;\r\n    let newTime =\r\n      resizeState.activeSegmentSide === \"left\"\r\n        ? resizeState.activeSegmentOffsetStart + change\r\n        : resizeState.activeSegmentOffsetEnd + change;\r\n\r\n    newTime = options.clampFn(newTime);\r\n    // Don't allow offset to become less than 0\r\n    if (newTime < 0) {\r\n      newTime = 0;\r\n    }\r\n\r\n    const active = resizeState.activeSegment;\r\n    const newDuration =\r\n      resizeState.activeSegmentSide === \"left\"\r\n        ? active.end - active.start - newTime\r\n        : newTime - active.start - active.offsetStart;\r\n\r\n    // Do not allow resizing\r\n    if (newDuration <= 2) {\r\n      return;\r\n    }\r\n\r\n    resizeState.activeSegmentSide === \"left\"\r\n      ? (active.offsetStart = newTime)\r\n      : (active.end = newTime);\r\n\r\n    manager.flatten([resizeState.dragWave.id]);\r\n    manager.process([resizeState.dragWave.id]);\r\n  });\r\n\r\n  hammer.on(\"panend\", ev => {\r\n    const target = manager.options.getEventTarget(ev.srcEvent);\r\n    if (\r\n      resizeState.options == null ||\r\n      !shouldHandle(target, resizeState.options)\r\n    )\r\n      return;\r\n\r\n    if (resizeState.startState != null && resizeState.activeSegment != null)\r\n      manager.emitSegment(resizeState.startState, {\r\n        ...resizeState.activeSegment\r\n      });\r\n\r\n    resizeState.activeSegment = null;\r\n    resizeState.activeSegmentOffsetStart = 0;\r\n    resizeState.activeSegmentOffsetEnd = 0;\r\n    resizeState.activeSegmentSide = null;\r\n    resizeState.dragWave = null;\r\n    resizeState.options = null;\r\n    resizeState.startState = null;\r\n  });\r\n}\r\n","import { DomOptions } from \"../config/dom-config\";\r\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param waveform Sampled data for each pixel, max at 0, min at 1 \r\n * @param options\r\n * @param ctx \r\n * @param color\r\n */\r\nexport default (waveform: Float32Array, options: DomOptions, ctx: CanvasRenderingContext2D, color: string) => {\r\n    const scale = options.height / 2;\r\n    const width = options.width;\r\n    \r\n    ctx.fillStyle = color;\r\n    ctx.clearRect(0, 0, width, options.height);\r\n    \r\n    for(let i = 0, inSegment = false, segmentStart = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        const pointInSegment = waveform[index + 3] === 1;\r\n        if(!inSegment && pointInSegment) {\r\n            inSegment = true;\r\n            segmentStart = i;\r\n        } else if (inSegment && (!pointInSegment || i === width - 1)) {\r\n            inSegment = false;\r\n            ctx.fillRect(segmentStart, 0, i - segmentStart, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fillStyle = 'black';\r\n    ctx.beginPath();\r\n    \r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n\r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index + 1] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.closePath();\r\n\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        if(waveform[index - 4 + 2] === 0 && waveform[index + 2] === 1) {\r\n            ctx.rect(i, 0, 1, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fill();\r\n}","import { DragState } from \"../models/dragstate\";\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\n\r\nexport default (manager: DomRenderWaveShaper, canvas: HTMLCanvasElement, dragState: DragState): () => void => {\r\n\r\n    const enterlistener = (ev: PointerEvent) => pointerEnter(ev);\r\n\r\n\r\n    /**\r\n     * Fires when the mouse moves over the container,\r\n     * If a segment is being dragged and the pointer moves\r\n     * into another canvas the segment is tranfered to the \r\n     * new canvas.\r\n     */\r\n    canvas.addEventListener('pointermove', enterlistener);\r\n\r\n    const destroy = () => {\r\n        canvas.removeEventListener('pointermove', enterlistener);\r\n    }\r\n\r\n    const pointerEnter = (ev: PointerEvent) => {\r\n        if (dragState.options == null || dragState.options.mode !== 'drag')\r\n            return;\r\n\r\n        if(dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n\r\n        const canvas = document.elementFromPoint(ev.clientX, ev.clientY);\r\n        if (canvas == null || !(canvas instanceof HTMLCanvasElement))\r\n            return;\r\n\r\n        const id = canvas.getAttribute('data-wave-id');\r\n        if (id == null) return;\r\n\r\n        const wave = manager.getTrack(id);\r\n        if (wave == null) return;\r\n\r\n        if (dragState.dragWave.id !== id) {\r\n            const index = dragState.dragWave.intervals.indexOf(dragState.activeSegment);\r\n            dragState.dragWave.intervals.splice(index, 1);\r\n\r\n            dragState.activeSegment.trackId = wave.id;\r\n            wave.intervals.push(dragState.activeSegment);\r\n\r\n            dragState.activeSegment.index = 1000;\r\n\r\n            const currentId = dragState.dragWave.id;\r\n            dragState.dragWave = wave;\r\n\r\n            manager.flatten([wave.id, currentId]);\r\n            manager.process([wave.id, currentId]);\r\n        }\r\n    }\r\n\r\n    return destroy;\r\n}","import { defaultConfig, ManagerOptions, ManagerInput } from \"waveshaper\";\r\n\r\nexport type InteractionMode = 'pan' | 'drag' | 'cut' | 'resize';\r\nexport type GenerateId = () => string;\r\nexport type GetTarget = (ev: Event) => HTMLElement;\r\n\r\n\r\nexport interface DomOptions extends ManagerOptions {\r\n    getEventTarget: GetTarget;\r\n    registerSetsActive: boolean;\r\n    height: number;\r\n    generateId: GenerateId;\r\n    mode: InteractionMode;\r\n    clampFn: (n: number) => number;\r\n}\r\n\r\nexport interface DomInput extends ManagerInput {\r\n    getEventTarget?: GetTarget;\r\n    registerSetsActive?: boolean;\r\n    height?: number;\r\n    generateId?: GenerateId;\r\n    mode?: InteractionMode;\r\n    clampFn?: (n: number) => number;\r\n}\r\n\r\nconst defaultDomOptions: DomOptions = {\r\n    ...defaultConfig,\r\n    mode: 'pan',\r\n    height: 150,\r\n    getEventTarget: (ev) => <HTMLElement>ev.target,\r\n    generateId: () => Math.random().toString(),\r\n    registerSetsActive: true,\r\n    clampFn: n => n\r\n}\r\n\r\nexport default defaultDomOptions;","import { AudioInterval, Track } from \"waveshaper\";\r\nimport { DomOptions } from \"../config/dom-config\";\r\n\r\nexport interface DragState {\r\n  activeSegment: AudioInterval | null;\r\n  activeSegmentStart: number;\r\n  dragWave: Track | null;\r\n  options: DomOptions | null;\r\n  duration: number;\r\n  dragging: boolean;\r\n  startState: AudioInterval | null;\r\n}\r\n\r\nexport const dragState: DragState = {\r\n  activeSegment: null,\r\n  activeSegmentStart: 0,\r\n  dragWave: null,\r\n  options: null,\r\n  duration: 0,\r\n  dragging: false,\r\n  startState: null\r\n};\r\n"],"sourceRoot":""}