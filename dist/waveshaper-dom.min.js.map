{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///waveshaper-dom.min.js","webpack:///webpack/bootstrap 665068be2f4bc2785f92","webpack:///./node_modules/waveshaper/dist/waveshaper.js","webpack:///external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammerjs\",\"umd\":\"hammerjs\"}","webpack:///./src/index.ts","webpack:///./src/core/domrender-waveshaper.ts","webpack:///./src/config/hammerconfig.ts","webpack:///./src/interactions/cut.ts","webpack:///./src/interactions/drag.ts","webpack:///./src/interactions/pan.ts","webpack:///./src/interactions/zoom.ts","webpack:///./src/interactions/resize.ts","webpack:///./src/render/line.ts","webpack:///./src/interactions/enter.ts","webpack:///./src/config/dom-config.ts","webpack:///./src/models/dragstate.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","peak_1","rms_1","flatten_1","Track","id","intervals","_this","getDuration","Math","max","apply","map","end","flattened","default","flatten","calculate","options","dataMap","meterType","sampleSize","ceil","samplesPerPixel","resolution","start","scrollPosition","startSecond","samplerate","secondsPerPixel","endSecond","width","peaks","Float32Array","currentIntervalIndex","findIndex","offsetStart","maxIntervalIncrementIndex","length","currentInterval","buffer","source","currentSecond","startBorder","endBorder","intervalBorder","secondsIntoInterval","startSample","floor","endSample","length_1","loopEnd","min","j","sample","set","posSum","negSum","count","val","sqrt","__assign","assign","t","arguments","segment","segments","sorted","sort","normalized","normalizeIndex","copied","copy","grouped","groupByIndex","weightedMerge","index","preNormalizeIndex","Number","MIN_SAFE_INTEGER","forEach","el","a","b","cmp","reduce","groups","interval","push","_i","_a","keys","merged","merge","combine","result","current","next","highIndexes","lowIndexes","highIndex","lowIndex","high","low","defaultOptions","waveshaper_1","WaveShaper","track_1","managerconfig_1","defaultConfig","rms","peak","tracks","Map","audioData","activeWaveShapers","callbackMap","optionsValid","Error","JSON","stringify","_options","_lastProcessResult","_duration","ids","getProcessIds","waveShaper","getTrack","process","toProcess","data","wave","invokeCallbacks","on","callBack","callbackArray","off","indexOf","splice","setOptions","setTracks","track","foundWave","setData","setActive","clearTracks","removeCallbacksById","delete","undefined","trackResult","callbacks","callback","Array","from","values","maxDuration","duration","domrender_waveshaper_1","__extends","extendStatics","setPrototypeOf","__proto__","__","constructor","create","Hammer","hammerconfig_1","cut_1","drag_1","pan_1","zoom_1","resize_1","line_1","enter_1","dom_config_1","dragstate_1","DomRenderWaveShaper","_super","unregister","unregisterMap","canvasMap","registerCanvas","canvas","color","ctx","getContext","classList","add","setAttribute","style","height","scale","devicePixelRatio","unregisterCanvas","dragState","registerSetsActive","concat","unregisterEvents","loadData","dat","fetch","url","then","res","arrayBuffer","decodeAudioData","audioBuffer","getChannelData","catch","e","console","log","setInteraction","element","hammer","destroy","clearInteraction","hammerOptions","touchAction","recognizers","Pan","direction","DIRECTION_HORIZONTAL","Pinch","enable","Tap","manager","shouldHandle","target","mode","hasAttribute","ev","getEventTarget","srcEvent","getAttribute","bb","getBoundingClientRect","time","center","x","left","find","newSegment","generateId","activeSegment","activeSegmentStart","dragWave","dragging","change","deltaX","newTime","default_1","panState","panMax","scrollWidth","endMargin","panStart","position","newPosition","zoomState","sppStart","maxWidth","sampleAtLeft","samplesInView","samplesToCenter","newSpp","newSamplesInView","newSamplesToCenter","newScroll","resizeState","activeSegmentSide","activeSegmentOffsetStart","activeSegmentOffsetEnd","active","waveform","fillStyle","clearRect","inSegment","segmentStart","pointInSegment","fillRect","beginPath","moveTo","lineTo","round","closePath","rect","fill","enterlistener","pointerEnter","downlistener","releasePointerCapture","pointerId","addEventListener","HTMLCanvasElement","currentId","removeEventListener","defaultDomOptions","random","toString"],"mappings":"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","file":"waveshaper-dom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hammerjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hammerjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WS\"] = factory(require(\"hammerjs\"));\n\telse\n\t\troot[\"WS\"] = factory(root[\"Hammer\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hammerjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hammerjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WS\"] = factory(require(\"hammerjs\"));\n\telse\n\t\troot[\"WS\"] = factory(root[\"Hammer\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waveshaper\"] = factory();\n\telse\n\t\troot[\"waveshaper\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar peak_1 = __webpack_require__(1);\r\nvar rms_1 = __webpack_require__(2);\r\nvar flatten_1 = __webpack_require__(3);\r\nvar Track = /** @class */ (function () {\r\n    function Track(id, intervals) {\r\n        var _this = this;\r\n        this.id = id;\r\n        this.intervals = intervals;\r\n        /**\r\n         * Gets the duration of the audio in seconds\r\n         *\r\n         * @returns Decimal value of total duration in seconds\r\n         */\r\n        this.getDuration = function () { return Math.max.apply(Math, _this.intervals.map(function (s) { return s.end; })); };\r\n        this.flattened = flatten_1.default(this.intervals);\r\n    }\r\n    Track.prototype.flatten = function () {\r\n        this.flattened = flatten_1.default(this.intervals);\r\n    };\r\n    /**\r\n     * Gets the summerized values for the current settings\r\n     *\r\n     * @param options\r\n     * @param dataMap\r\n     * @returns Two dimensional array, one entry for each pixel, for each pixel a min\r\n     * and a max value.\r\n     */\r\n    Track.prototype.calculate = function (options, dataMap) {\r\n        switch (options.meterType) {\r\n            case 'peak':\r\n                return peak_1.default(options, this.flattened, dataMap);\r\n            default:\r\n                return rms_1.default(options, this.flattened, dataMap);\r\n        }\r\n    };\r\n    return Track;\r\n}());\r\nexports.default = Track;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates peak values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var min = 0, max = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize) {\r\n            var sample = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (sample > max)\r\n                max = sample;\r\n            else if (sample < min)\r\n                min = sample;\r\n        }\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculate rms values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var posSum = 0, negSum = 0, count = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize, count++) {\r\n            var val = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (val > 0) {\r\n                posSum += val * val;\r\n            }\r\n            else {\r\n                negSum += val * val;\r\n            }\r\n        }\r\n        var min = -Math.sqrt(negSum / count);\r\n        var max = Math.sqrt(posSum / count);\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar start = function (segment) { return segment.start + segment.offsetStart; };\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param segments Segments to flatten\r\n * @returns flattened Interval array\r\n */\r\nexports.default = (function (segments) {\r\n    var sorted = sort(segments);\r\n    var normalized = normalizeIndex(sorted);\r\n    var copied = copy(normalized);\r\n    var grouped = groupByIndex(copied);\r\n    return weightedMerge(grouped);\r\n});\r\n/**\r\n * Copies elements so original are unaltered\r\n *\r\n * @param intervals\r\n */\r\nvar copy = function (intervals) { return intervals.map(function (i) { return (__assign({}, i)); }); };\r\n/**\r\n * When an element is altered the index is set very high,\r\n * this functions normalizes to indexes back to 0\r\n *\r\n * @param segments\r\n */\r\nvar normalizeIndex = function (segments) {\r\n    var index = 0;\r\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\r\n    segments.forEach(function (el) {\r\n        if (el.index > preNormalizeIndex) {\r\n            preNormalizeIndex = el.index;\r\n            el.index = ++index;\r\n        }\r\n        else {\r\n            el.index = index;\r\n        }\r\n    });\r\n    return segments;\r\n};\r\n/**\r\n * Sorts the intervals by index, then by start\r\n *\r\n * @param intervals\r\n * @return Interval array\r\n */\r\nvar sort = function (intervals) {\r\n    return intervals.sort(function (a, b) { return cmp(a.index, b.index) || cmp(start(a), start(b)); });\r\n};\r\n/**\r\n * Returns a map of intervals grouped by the key property\r\n *\r\n * @param intervals\r\n * @param key\r\n *\r\n * @returns Map of index => interval[]\r\n */\r\nvar groupByIndex = function (intervals) {\r\n    return intervals.reduce(function (groups, interval) {\r\n        (groups[interval.index] = groups[interval.index] || []).push(interval);\r\n        return groups;\r\n    }, {});\r\n};\r\n/**\r\n * Merges all the groups by index\r\n *\r\n * @param grouped\r\n * @returns Interval array\r\n */\r\nvar weightedMerge = function (grouped) {\r\n    var flattened = null;\r\n    for (var _i = 0, _a = Object.keys(grouped); _i < _a.length; _i++) {\r\n        var index = _a[_i];\r\n        var merged = merge(grouped[index]);\r\n        if (flattened == null) {\r\n            flattened = merged;\r\n        }\r\n        else {\r\n            flattened = combine(merged, flattened);\r\n        }\r\n    }\r\n    return flattened;\r\n};\r\n/**\r\n * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n *\r\n * @param intervals\r\n * @returns Interval array\r\n */\r\nvar merge = function (intervals) {\r\n    if (intervals.length <= 1)\r\n        return intervals;\r\n    var result = [];\r\n    var current = intervals[0];\r\n    for (var i = 1; i < intervals.length; i++) {\r\n        var next = intervals[i];\r\n        // If current is completely overlapped by second it is merged into it\r\n        if (current.end >= next.end) {\r\n            continue;\r\n            // Resolves partial overlaps by setting end of current to start of next\r\n        }\r\n        else if (start(next) < current.end) {\r\n            result.push(__assign({}, current, { end: start(next) }));\r\n            current = next;\r\n        }\r\n        else {\r\n            // No overlap, push onto results\r\n            result.push(current);\r\n            current = next;\r\n        }\r\n    }\r\n    result.push(current);\r\n    return result;\r\n};\r\n/**\r\n * Given two sets of intervals it merges them so the highIndexes set has priority\r\n *\r\n * @param highIndexes\r\n * @param lowIndexes\r\n *\r\n * @returns Interval array\r\n */\r\nvar combine = function (highIndexes, lowIndexes) {\r\n    var highIndex = 0;\r\n    var lowIndex = 0;\r\n    var merged = [];\r\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\r\n        var high = highIndexes[highIndex];\r\n        var low = lowIndexes[lowIndex];\r\n        // Only low priority left so push low onto results\r\n        if (highIndex === highIndexes.length) {\r\n            merged.push(__assign({}, low));\r\n            lowIndex++;\r\n            // Only high priority left so push high onto results\r\n        }\r\n        else if (lowIndex === lowIndexes.length) {\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // High priority start before or at same time as low\r\n        }\r\n        else if (start(high) <= start(low)) {\r\n            // No overlap between low and high\r\n            // low:                 ----------------------\r\n            // high: ---------------\r\n            if (high.end <= start(low)) {\r\n                // Partial overlap where high ends after low\r\n                // low:                 ----------------------\r\n                // high: ----------------------\r\n            }\r\n            else if (high.end < low.end) {\r\n                low.offsetStart = high.end - low.start;\r\n                // Low index completely overlapped, dismiss it\r\n                // low:               -----------\r\n                // high: -------------------------------------\r\n            }\r\n            else {\r\n                lowIndex++;\r\n            }\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // Low priority starts before high\r\n        }\r\n        else {\r\n            // No overlap between low and high intervals\r\n            // low: ---------------\r\n            // high                ----------------------\r\n            if (low.end <= start(high)) {\r\n                merged.push(__assign({}, low));\r\n                lowIndex++;\r\n                // Partial overlap where high ends after low\r\n                // low: ---------------------\r\n                // high                ----------------------\r\n            }\r\n            else if (high.end > low.end) {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                lowIndex++;\r\n                // Partial overlap where high ends before low\r\n                // low: -------------------------------------\r\n                // high             -----------\r\n            }\r\n            else {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                low.offsetStart = high.end - low.start;\r\n            }\r\n        }\r\n    }\r\n    return merged;\r\n};\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nvar cmp = function (a, b) {\r\n    if (a > b)\r\n        return +1;\r\n    if (a < b)\r\n        return -1;\r\n    return 0;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 10,\r\n    meterType: 'rms',\r\n    width: 300,\r\n    samplerate: 44100\r\n};\r\nexports.default = defaultOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(6);\r\nexports.WaveShaper = waveshaper_1.default;\r\nvar track_1 = __webpack_require__(0);\r\nexports.Track = track_1.default;\r\nvar managerconfig_1 = __webpack_require__(4);\r\nexports.defaultConfig = managerconfig_1.default;\r\nvar rms_1 = __webpack_require__(2);\r\nexports.rms = rms_1.default;\r\nvar peak_1 = __webpack_require__(1);\r\nexports.peak = peak_1.default;\r\nvar flatten_1 = __webpack_require__(3);\r\nexports.flatten = flatten_1.default;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar track_1 = __webpack_require__(0);\r\nvar managerconfig_1 = __webpack_require__(4);\r\n/**\r\n *\r\n *\r\n * @export\r\n */\r\nvar WaveShaper = /** @class */ (function () {\r\n    /**\r\n     * @param [options=defaultOptions] Initial options\r\n     * @throws Throws an error if samplerate is null or NaN\r\n     */\r\n    function WaveShaper(options) {\r\n        if (options === void 0) { options = managerconfig_1.default; }\r\n        /**\r\n         * Map of waveshapers managed by the manager\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.tracks = new Map();\r\n        /**\r\n         * Map of audio data\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.audioData = new Map();\r\n        /**\r\n         * @description Active id's, redraws when draw is called without argument\r\n         *\r\n         * @memberof WaveShaper\r\n         */\r\n        this.activeWaveShapers = [];\r\n        /**\r\n         * @description Map of callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.callbackMap = new Map();\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, managerconfig_1.default, options);\r\n    }\r\n    Object.defineProperty(WaveShaper.prototype, \"options\", {\r\n        /**\r\n         * @description Currect settings\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"lastProcessResult\", {\r\n        /**\r\n         * @description Last result of calling process, argument given to all callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._lastProcessResult; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"duration\", {\r\n        /**\r\n         * @description Total duration of all tracks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._duration; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     *\r\n     * @param id\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.flatten = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.getProcessIds.apply(this, ids).forEach(function (id) {\r\n            var waveShaper = _this.getTrack(id);\r\n            if (waveShaper != null)\r\n                waveShaper.flatten();\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Processes all relevant WaveShapers and invokes registered callbacks\r\n     *\r\n     * @param ids Options array of id's to draw\r\n     * @param forceDraw Force redraw of the given waves\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.process = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        var toProcess = this.getProcessIds.apply(this, ids);\r\n        var options = __assign({}, this.options);\r\n        var data = [];\r\n        for (var i = 0; i < toProcess.length; i++) {\r\n            var id = toProcess[i];\r\n            var wave = this.getTrack(id);\r\n            if (wave == null)\r\n                continue;\r\n            var peaks = wave.calculate(options, this.audioData);\r\n            data.push({ id: id, data: peaks });\r\n        }\r\n        // Invoke callbacks after returning value.\r\n        this._lastProcessResult = { options: options, data: data };\r\n        this.invokeCallbacks(this._lastProcessResult);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a callback that fires when the track with given id is processed\r\n     *\r\n     * @param id id of Track to register to\r\n     * @param callBack will be invoked when the given track is processed\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.on = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null) {\r\n            this.callbackMap.set(id, [callBack]);\r\n        }\r\n        else {\r\n            callbackArray.push(callBack);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters a callback from the given track, will no longer be called\r\n     *\r\n     * @param id id of Track to unregister from\r\n     * @param callBack callback to remove\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.off = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return this;\r\n        var index = callbackArray.indexOf(callBack);\r\n        if (index < 0)\r\n            return this;\r\n        callbackArray = callbackArray.splice(index, 1);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Merges the given options into the current and returns updated options\r\n     *\r\n     * @param options A (partial) ManagerOptions object\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setOptions = function (options) {\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, this.options, options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     *\r\n     * @param id id of WaveShaper\r\n     * @param segments Segments in wave\r\n     * @param color Background color of segments\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setTracks = function () {\r\n        var _this = this;\r\n        var tracks = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tracks[_i] = arguments[_i];\r\n        }\r\n        tracks.forEach(function (track) {\r\n            var foundWave = _this.getTrack(track.id);\r\n            if (foundWave == null) {\r\n                var wave = new track_1.default(track.id, track.intervals);\r\n                _this.tracks.set(track.id, wave);\r\n            }\r\n            else {\r\n                foundWave.intervals = track.intervals;\r\n                foundWave.flatten();\r\n            }\r\n        });\r\n        this._duration = this.getDuration();\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds audio data to the waveshaper and redraws waveshapers using it\r\n     *\r\n     * @param id  Data id, refered to by source parameter of segments\r\n     * @param data AudioBuffer with audio data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setData = function () {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            data[_i] = arguments[_i];\r\n        }\r\n        data.forEach(function (d) {\r\n            _this.audioData.set(d.id, d.data);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description The given id's are set as the active waveshapers, process only processes these when set,\r\n     * call with no values to allways process all values (default)\r\n     *\r\n     * @param ids Waveshaper id's to set as active\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setActive = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.activeWaveShapers = ids;\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Removes the waves and all callbacks with given id from the manager\r\n     *\r\n     * @param id\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.clearTracks = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        ids.forEach(function (id) {\r\n            _this.removeCallbacksById(id);\r\n            _this.tracks.delete(id);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Gets Track with given id\r\n     *\r\n     * @param id\r\n     * @returns Track with given ID\r\n     */\r\n    WaveShaper.prototype.getTrack = function (id) {\r\n        return this.tracks.get(id);\r\n    };\r\n    /**\r\n     * Validates given options\r\n     *\r\n     * @param options\r\n     * @returns true if valid, false if not\r\n     */\r\n    WaveShaper.prototype.optionsValid = function (options) {\r\n        return (options.samplesPerPixel === undefined || options.samplesPerPixel > 0) &&\r\n            (options.meterType === undefined || options.meterType) &&\r\n            (options.resolution === undefined || options.resolution > 0) &&\r\n            (options.width === undefined || options.width > 0) &&\r\n            (options.scrollPosition === undefined || options.scrollPosition >= 0) &&\r\n            (options.samplerate === undefined || options.samplerate > 0);\r\n    };\r\n    /**\r\n     * Invokes all registered callbacks registered to a waveshaper id in the data list\r\n     *\r\n     * @param options\r\n     * @param data\r\n     */\r\n    WaveShaper.prototype.invokeCallbacks = function (result) {\r\n        for (var i = 0; i < result.data.length; i++) {\r\n            var trackResult = result.data[i];\r\n            var callbacks = this.callbackMap.get(trackResult.id);\r\n            if (callbacks == null)\r\n                continue;\r\n            for (var j = 0; j < callbacks.length; j++) {\r\n                var callback = callbacks[j];\r\n                callback(result.options, new Float32Array(trackResult.data));\r\n            }\r\n        }\r\n    };\r\n    WaveShaper.prototype.getProcessIds = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        if (ids.length > 0)\r\n            return ids;\r\n        if (this.activeWaveShapers && this.activeWaveShapers.length > 0)\r\n            return this.activeWaveShapers;\r\n        return Array.from(this.tracks.keys());\r\n    };\r\n    WaveShaper.prototype.removeCallbacksById = function (id) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return;\r\n        callbackArray.splice(0, callbackArray.length);\r\n        this.callbackMap.delete(id);\r\n    };\r\n    /**\r\n     * @description Returns the maximum duration of all the waveshapers managed by this class\r\n     *\r\n     * @returns Maximum duration in seconds\r\n     * @memberof WaveShaper\r\n     */\r\n    WaveShaper.prototype.getDuration = function () {\r\n        return Array.from(this.tracks.values()).reduce(function (maxDuration, waveShaper) {\r\n            var duration = waveShaper.getDuration();\r\n            return duration > maxDuration ? duration : maxDuration;\r\n        }, 0);\r\n    };\r\n    return WaveShaper;\r\n}());\r\nexports.default = WaveShaper;\r\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=waveshaper.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar domrender_waveshaper_1 = __webpack_require__(3);\r\nexports.default = new domrender_waveshaper_1.default();\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(0);\r\nvar Hammer = __webpack_require__(1);\r\nvar hammerconfig_1 = __webpack_require__(4);\r\nvar cut_1 = __webpack_require__(5);\r\nvar drag_1 = __webpack_require__(6);\r\nvar pan_1 = __webpack_require__(7);\r\nvar zoom_1 = __webpack_require__(8);\r\nvar resize_1 = __webpack_require__(9);\r\nvar line_1 = __webpack_require__(10);\r\nvar enter_1 = __webpack_require__(11);\r\nvar dom_config_1 = __webpack_require__(12);\r\nvar dragstate_1 = __webpack_require__(13);\r\n/**\r\n * Extends WaveShapeManager to allow for easy canvas rendering registration.\r\n *\r\n * @inheritDoc\r\n */\r\nvar DomRenderWaveShaper = /** @class */ (function (_super) {\r\n    __extends(DomRenderWaveShaper, _super);\r\n    function DomRenderWaveShaper(options) {\r\n        if (options === void 0) { options = dom_config_1.default; }\r\n        var _this = _super.call(this, options) || this;\r\n        _this.unregister = function () { };\r\n        _this.unregisterMap = new Map();\r\n        _this.canvasMap = new Map();\r\n        _this._options = __assign({}, dom_config_1.default, _this._options);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"scrollWidth\", {\r\n        get: function () { return (this._duration * this._options.samplerate) / this._options.samplesPerPixel; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"options\", {\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @description When a canvas is registered through this method each time the\r\n     * waveform is updated the canvas will be rerendered.\r\n     *\r\n     * It returns an unregister method, call to stop receiving callbacks.\r\n     *\r\n     * @param id WaveShaper id to register to.\r\n     * @param canvas Canvas to render to\r\n     * @param color Background color of segments\r\n     */\r\n    DomRenderWaveShaper.prototype.registerCanvas = function (id, canvas, color) {\r\n        var _this = this;\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx == null)\r\n            throw Error('Cannot get context from canvas.');\r\n        // Add classes and data attributes\r\n        canvas.classList.add('waveshaper');\r\n        canvas.setAttribute('data-wave-id', id);\r\n        canvas.style.width = this.options.width + 'px';\r\n        canvas.style.height = this.options.height + 'px';\r\n        var scale = (devicePixelRatio || 1) < 1 ? 1 : (devicePixelRatio || 1);\r\n        canvas.width = this.options.width * scale;\r\n        canvas.height = this.options.height;\r\n        ctx.scale(scale, 1);\r\n        var callBack = function (options, data) { return line_1.default(data, options, ctx, color); };\r\n        this.on(id, callBack);\r\n        this.unregisterCanvas(id);\r\n        this.canvasMap.set(id, function () { return _this.off(id, callBack); });\r\n        var unregister = enter_1.default(this, canvas, dragstate_1.dragState);\r\n        this.unregisterMap.set(id, unregister);\r\n        // If registerSetsActive is true \r\n        if (this._options.registerSetsActive) {\r\n            if (this.activeWaveShapers)\r\n                this.setActive.apply(this, this.activeWaveShapers.concat(id));\r\n            else\r\n                this.setActive(id);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Clears the callbacks associated with this canvas\r\n     *\r\n     * @param id\r\n     * @returns Instance of WaveShaper\r\n     */\r\n    DomRenderWaveShaper.prototype.unregisterCanvas = function (id) {\r\n        var unregister = this.canvasMap.get(id);\r\n        if (unregister != null) {\r\n            unregister();\r\n            this.canvasMap.delete(id);\r\n        }\r\n        var unregisterEvents = this.unregisterMap.get(id);\r\n        if (unregisterEvents != null) {\r\n            unregisterEvents();\r\n            this.unregisterMap.delete(id);\r\n        }\r\n        if (this._options.registerSetsActive) {\r\n            if (this.activeWaveShapers) {\r\n                var index = this.activeWaveShapers.indexOf(id);\r\n                if (index != -1)\r\n                    this.setActive.apply(this, this.activeWaveShapers.splice(index, 1));\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Loads and saves a set of url's to audio files.\r\n     *\r\n     * @param ctx\r\n     * @param data\r\n     */\r\n    DomRenderWaveShaper.prototype.loadData = function (ctx) {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            data[_i - 1] = arguments[_i];\r\n        }\r\n        data.forEach(function (dat) {\r\n            fetch(dat.url)\r\n                .then(function (res) { return res.arrayBuffer(); })\r\n                .then(function (arrayBuffer) { return ctx.decodeAudioData(arrayBuffer); })\r\n                .then(function (audioBuffer) {\r\n                _this.setData({ id: dat.id, data: audioBuffer.getChannelData(0) }).process();\r\n            })\r\n                .catch(function (e) { return console.log(e); });\r\n        });\r\n        return this;\r\n    };\r\n    DomRenderWaveShaper.prototype.setInteraction = function (element) {\r\n        if (element == null)\r\n            throw Error('Interaction container element could not be found.');\r\n        this.unregister();\r\n        element.setAttribute('touch-action', 'none');\r\n        var hammer = new Hammer(element, hammerconfig_1.default);\r\n        drag_1.default(this, hammer, dragstate_1.dragState);\r\n        cut_1.default(this, hammer);\r\n        pan_1.default(this, hammer);\r\n        zoom_1.default(this, hammer);\r\n        resize_1.default(this, hammer);\r\n        this.unregister = function () {\r\n            hammer.destroy();\r\n        };\r\n        return this;\r\n    };\r\n    DomRenderWaveShaper.prototype.clearInteraction = function () {\r\n        this.unregister();\r\n        this.unregister = function () { };\r\n    };\r\n    return DomRenderWaveShaper;\r\n}(waveshaper_1.WaveShaper));\r\nexports.default = DomRenderWaveShaper;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Hammer = __webpack_require__(1);\r\nvar hammerOptions = {\r\n    touchAction: 'pan-y',\r\n    recognizers: [\r\n        [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }],\r\n        [Hammer.Pinch, { enable: true }],\r\n        [Hammer.Tap]\r\n    ]\r\n};\r\nexports.default = hammerOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nexports.default = (function (manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'cut' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('tap', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (options == null || !shouldHandle(target, options))\r\n            return;\r\n        var id = target.getAttribute('data-wave-id');\r\n        if (id == null)\r\n            return;\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = ev.target.getBoundingClientRect();\r\n        var time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        var newSegment = __assign({}, segment, { offsetStart: time - segment.start, id: options.generateId() });\r\n        segment.end = time;\r\n        wave.intervals.push(newSegment);\r\n        manager.flatten(wave.id);\r\n        manager.process(wave.id);\r\n    });\r\n});\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager Waveshape Manager\r\n * @param hammer Hammer instance\r\n * @param container Container element\r\n */\r\nexports.default = (function (manager, hammer, dragState) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'drag' && target.hasAttribute('data-wave-id'); };\r\n    /**\r\n     * Sets up the drag by finding the\r\n     */\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        var id = target.getAttribute('data-wave-id');\r\n        if (id == null)\r\n            return;\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = ev.target.getBoundingClientRect();\r\n        var time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        dragState.options = options;\r\n        dragState.activeSegment = segment;\r\n        dragState.activeSegmentStart = dragState.activeSegment.start;\r\n        dragState.duration = segment.end - segment.start;\r\n        dragState.activeSegment.index = 1000;\r\n        dragState.dragWave = wave;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n        if (dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n        if (dragState.dragging)\r\n            return;\r\n        dragState.dragging = true;\r\n        /**\r\n         * TODO below implementation stops all updates on touch devices on new track (tested on Samsung Galaxy s8),\r\n         * when dragged back to original keeps working. Works on desktop, it's a small performance improvement as\r\n         * it prevents a single track flatten + process when transferring a segment between tracks.\r\n         */\r\n        //// If the target has moved it is handled by the mouseHover function\r\n        // const id = ev.target.getAttribute('data-wave-id');\r\n        // if(id !== dragState.dragWave.id)\r\n        //     return;\r\n        var change = (ev.deltaX * dragState.options.samplesPerPixel) / dragState.options.samplerate;\r\n        var newTime = dragState.activeSegmentStart + change;\r\n        if (newTime + dragState.activeSegment.offsetStart < 0) {\r\n            newTime = -dragState.activeSegment.offsetStart;\r\n        }\r\n        dragState.activeSegment.start = newTime;\r\n        dragState.activeSegment.end = newTime + dragState.duration;\r\n        manager.flatten(dragState.dragWave.id);\r\n        manager.process(dragState.dragWave.id);\r\n        dragState.dragging = false;\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n        dragState.activeSegment = null;\r\n        dragState.activeSegmentStart = 0;\r\n        dragState.dragWave = null;\r\n        dragState.options = null;\r\n        dragState.duration = 0;\r\n    });\r\n});\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar endMargin = 500;\r\nvar panState = {\r\n    panStart: 0,\r\n    panMax: 0,\r\n    options: null\r\n};\r\n/**\r\n * Adds pan functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'pan' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        panState.panMax = manager.scrollWidth + endMargin;\r\n        panState.panStart = options.scrollPosition;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        panState.options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, panState.options))\r\n            return;\r\n        var position = panState.panStart - ev.deltaX;\r\n        var newPosition = position > 0 ? position : 0;\r\n        // If it was and is still 0 no need to update\r\n        if (newPosition === panState.options.scrollPosition)\r\n            return;\r\n        if (position > panState.panMax - panState.options.width)\r\n            return;\r\n        manager.setOptions({ scrollPosition: newPosition }).process();\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (panState.options == null || !shouldHandle(target, panState.options))\r\n            return;\r\n        panState.options = null;\r\n        panState.panStart = 0;\r\n        panState.panMax = 0;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar endMargin = 500;\r\nvar zoomState = {\r\n    maxWidth: 0,\r\n    sppStart: 0,\r\n    options: null\r\n};\r\n/**\r\n * Adds pinch zoom functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'pan' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('pinchstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        zoomState.sppStart = options.samplesPerPixel;\r\n        zoomState.maxWidth = manager.scrollWidth + endMargin;\r\n    });\r\n    hammer.on('pinchmove', function (ev) {\r\n        zoomState.options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n        var sampleAtLeft = zoomState.options.scrollPosition * zoomState.options.samplesPerPixel;\r\n        var samplesInView = zoomState.options.width * zoomState.options.samplesPerPixel;\r\n        var samplesToCenter = samplesInView / 2;\r\n        var newSpp = zoomState.sppStart * ev.scale;\r\n        var newSamplesInView = zoomState.options.width * newSpp;\r\n        var newSamplesToCenter = newSamplesInView / 2;\r\n        var maxWidth = manager.scrollWidth + endMargin;\r\n        var maxSamplesInView = maxWidth * zoomState.options.samplerate;\r\n        if (newSamplesInView >= maxSamplesInView)\r\n            return;\r\n        var newScroll = (sampleAtLeft + samplesToCenter - newSamplesToCenter) / newSpp;\r\n        manager.setOptions({\r\n            samplesPerPixel: newSpp,\r\n            scrollPosition: newScroll >= 0 ? newScroll : 0\r\n        }).process();\r\n    });\r\n    hammer.on('pinchend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n        zoomState.sppStart = 0;\r\n        zoomState.maxWidth = 0;\r\n        zoomState.options = null;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar resizeState = {\r\n    activeSegment: null,\r\n    activeSegmentSide: null,\r\n    activeSegmentOffsetStart: 0,\r\n    activeSegmentOffsetEnd: 0,\r\n    dragWave: null,\r\n    options: null\r\n};\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'resize' && target != null && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        var id = target.getAttribute('data-wave-id');\r\n        if (id == null)\r\n            return;\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = ev.target.getBoundingClientRect();\r\n        var time = (options.scrollPosition + (ev.center.x - bb.left)) * options.samplesPerPixel / options.samplerate;\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        resizeState.activeSegmentSide =\r\n            time < interval.start + interval.offsetStart + ((interval.end - (interval.start + interval.offsetStart)) / 2) ?\r\n                'left' :\r\n                'right';\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        resizeState.options = options;\r\n        resizeState.activeSegment = segment;\r\n        resizeState.activeSegmentOffsetStart = segment.offsetStart;\r\n        resizeState.activeSegmentOffsetEnd = segment.end;\r\n        segment.index = 1000;\r\n        resizeState.dragWave = wave;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (resizeState.dragWave == null || resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n        var options = manager.options;\r\n        if (resizeState.activeSegment == null)\r\n            return;\r\n        var change = (ev.deltaX * options.samplesPerPixel) / options.samplerate;\r\n        var newTime = resizeState.activeSegmentSide === 'left' ?\r\n            resizeState.activeSegmentOffsetStart + change :\r\n            resizeState.activeSegmentOffsetEnd + change;\r\n        // Don't allow offset to become less than 0\r\n        if (newTime < 0) {\r\n            newTime = 0;\r\n        }\r\n        var active = resizeState.activeSegment;\r\n        var newDuration = resizeState.activeSegmentSide === 'left' ?\r\n            active.end - active.start - newTime :\r\n            newTime - active.start - active.offsetStart;\r\n        // Do not allow resizing \r\n        if (newDuration <= 2) {\r\n            return;\r\n        }\r\n        resizeState.activeSegmentSide === 'left' ?\r\n            active.offsetStart = newTime :\r\n            active.end = newTime;\r\n        manager.flatten(resizeState.dragWave.id);\r\n        manager.process(resizeState.dragWave.id);\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n        resizeState.activeSegment = null;\r\n        resizeState.activeSegmentOffsetStart = 0;\r\n        resizeState.activeSegmentOffsetEnd = 0;\r\n        resizeState.activeSegmentSide = null;\r\n        resizeState.dragWave = null;\r\n        resizeState.options = null;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n *\r\n *\r\n * @export\r\n * @param waveform Sampled data for each pixel, max at 0, min at 1\r\n * @param options\r\n * @param ctx\r\n * @param color\r\n */\r\nexports.default = (function (waveform, options, ctx, color) {\r\n    var scale = options.height / 2;\r\n    var width = options.width;\r\n    ctx.fillStyle = color;\r\n    ctx.clearRect(0, 0, width, options.height);\r\n    for (var i = 0, inSegment = false, segmentStart = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        var pointInSegment = waveform[index + 3] === 1;\r\n        if (!inSegment && pointInSegment) {\r\n            inSegment = true;\r\n            segmentStart = i;\r\n        }\r\n        else if (inSegment && (!pointInSegment || i === width - 1)) {\r\n            inSegment = false;\r\n            ctx.fillRect(segmentStart, 0, i - segmentStart, options.height);\r\n        }\r\n    }\r\n    ctx.fillStyle = 'black';\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, scale);\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        ctx.lineTo(i, Math.round((waveform[index] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.moveTo(0, scale);\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        ctx.lineTo(i, Math.round((waveform[index + 1] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.closePath();\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        if (waveform[index - 4 + 2] === 0 && waveform[index + 2] === 1) {\r\n            ctx.rect(i, 0, 1, options.height);\r\n        }\r\n    }\r\n    ctx.fill();\r\n});\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = (function (manager, canvas, dragState) {\r\n    var enterlistener = function (ev) { return pointerEnter(ev); };\r\n    var downlistener = function (ev) { return canvas.releasePointerCapture(ev.pointerId); };\r\n    /**\r\n     * Fires when the mouse moves over the container,\r\n     * If a segment is being dragged and the pointer moves\r\n     * into another canvas the segment is tranfered to the\r\n     * new canvas.\r\n     */\r\n    canvas.addEventListener('pointerenter', enterlistener);\r\n    canvas.addEventListener('pointerdown', downlistener);\r\n    var destroy = function () {\r\n        canvas.removeEventListener('pointerenter', enterlistener);\r\n        canvas.removeEventListener('pointerdown', downlistener);\r\n    };\r\n    var pointerEnter = function (ev) {\r\n        if (dragState.options == null || dragState.options.mode !== 'drag')\r\n            return;\r\n        if (dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n        var canvas = dragState.options.getEventTarget(ev);\r\n        if (canvas == null || !(canvas instanceof HTMLCanvasElement))\r\n            return;\r\n        var id = canvas.getAttribute('data-wave-id');\r\n        if (id == null)\r\n            return;\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        if (dragState.dragWave.id !== id) {\r\n            var index = dragState.dragWave.intervals.indexOf(dragState.activeSegment);\r\n            dragState.dragWave.intervals.splice(index, 1);\r\n            wave.intervals.push(dragState.activeSegment);\r\n            dragState.activeSegment.index = 1000;\r\n            var currentId = dragState.dragWave.id;\r\n            dragState.dragWave = wave;\r\n            manager.flatten(wave.id, currentId);\r\n            manager.process(wave.id, currentId);\r\n        }\r\n    };\r\n    return destroy;\r\n});\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(0);\r\nvar defaultDomOptions = __assign({}, waveshaper_1.defaultConfig, { mode: 'pan', height: 150, getEventTarget: function (ev) { return ev.target; }, generateId: function () { return Math.random().toString(); }, registerSetsActive: true });\r\nexports.default = defaultDomOptions;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.dragState = {\r\n    activeSegment: null,\r\n    activeSegmentStart: 0,\r\n    dragWave: null,\r\n    options: null,\r\n    duration: 0,\r\n    dragging: false\r\n};\r\n\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// waveshaper-dom.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 665068be2f4bc2785f92","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waveshaper\"] = factory();\n\telse\n\t\troot[\"waveshaper\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar peak_1 = __webpack_require__(1);\r\nvar rms_1 = __webpack_require__(2);\r\nvar flatten_1 = __webpack_require__(3);\r\nvar Track = /** @class */ (function () {\r\n    function Track(id, intervals) {\r\n        var _this = this;\r\n        this.id = id;\r\n        this.intervals = intervals;\r\n        /**\r\n         * Gets the duration of the audio in seconds\r\n         *\r\n         * @returns Decimal value of total duration in seconds\r\n         */\r\n        this.getDuration = function () { return Math.max.apply(Math, _this.intervals.map(function (s) { return s.end; })); };\r\n        this.flattened = flatten_1.default(this.intervals);\r\n    }\r\n    Track.prototype.flatten = function () {\r\n        this.flattened = flatten_1.default(this.intervals);\r\n    };\r\n    /**\r\n     * Gets the summerized values for the current settings\r\n     *\r\n     * @param options\r\n     * @param dataMap\r\n     * @returns Two dimensional array, one entry for each pixel, for each pixel a min\r\n     * and a max value.\r\n     */\r\n    Track.prototype.calculate = function (options, dataMap) {\r\n        switch (options.meterType) {\r\n            case 'peak':\r\n                return peak_1.default(options, this.flattened, dataMap);\r\n            default:\r\n                return rms_1.default(options, this.flattened, dataMap);\r\n        }\r\n    };\r\n    return Track;\r\n}());\r\nexports.default = Track;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates peak values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var min = 0, max = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize) {\r\n            var sample = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (sample > max)\r\n                max = sample;\r\n            else if (sample < min)\r\n                min = sample;\r\n        }\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculate rms values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var posSum = 0, negSum = 0, count = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize, count++) {\r\n            var val = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (val > 0) {\r\n                posSum += val * val;\r\n            }\r\n            else {\r\n                negSum += val * val;\r\n            }\r\n        }\r\n        var min = -Math.sqrt(negSum / count);\r\n        var max = Math.sqrt(posSum / count);\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar start = function (segment) { return segment.start + segment.offsetStart; };\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param segments Segments to flatten\r\n * @returns flattened Interval array\r\n */\r\nexports.default = (function (segments) {\r\n    var sorted = sort(segments);\r\n    var normalized = normalizeIndex(sorted);\r\n    var copied = copy(normalized);\r\n    var grouped = groupByIndex(copied);\r\n    return weightedMerge(grouped);\r\n});\r\n/**\r\n * Copies elements so original are unaltered\r\n *\r\n * @param intervals\r\n */\r\nvar copy = function (intervals) { return intervals.map(function (i) { return (__assign({}, i)); }); };\r\n/**\r\n * When an element is altered the index is set very high,\r\n * this functions normalizes to indexes back to 0\r\n *\r\n * @param segments\r\n */\r\nvar normalizeIndex = function (segments) {\r\n    var index = 0;\r\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\r\n    segments.forEach(function (el) {\r\n        if (el.index > preNormalizeIndex) {\r\n            preNormalizeIndex = el.index;\r\n            el.index = ++index;\r\n        }\r\n        else {\r\n            el.index = index;\r\n        }\r\n    });\r\n    return segments;\r\n};\r\n/**\r\n * Sorts the intervals by index, then by start\r\n *\r\n * @param intervals\r\n * @return Interval array\r\n */\r\nvar sort = function (intervals) {\r\n    return intervals.sort(function (a, b) { return cmp(a.index, b.index) || cmp(start(a), start(b)); });\r\n};\r\n/**\r\n * Returns a map of intervals grouped by the key property\r\n *\r\n * @param intervals\r\n * @param key\r\n *\r\n * @returns Map of index => interval[]\r\n */\r\nvar groupByIndex = function (intervals) {\r\n    return intervals.reduce(function (groups, interval) {\r\n        (groups[interval.index] = groups[interval.index] || []).push(interval);\r\n        return groups;\r\n    }, {});\r\n};\r\n/**\r\n * Merges all the groups by index\r\n *\r\n * @param grouped\r\n * @returns Interval array\r\n */\r\nvar weightedMerge = function (grouped) {\r\n    var flattened = null;\r\n    for (var _i = 0, _a = Object.keys(grouped); _i < _a.length; _i++) {\r\n        var index = _a[_i];\r\n        var merged = merge(grouped[index]);\r\n        if (flattened == null) {\r\n            flattened = merged;\r\n        }\r\n        else {\r\n            flattened = combine(merged, flattened);\r\n        }\r\n    }\r\n    return flattened;\r\n};\r\n/**\r\n * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n *\r\n * @param intervals\r\n * @returns Interval array\r\n */\r\nvar merge = function (intervals) {\r\n    if (intervals.length <= 1)\r\n        return intervals;\r\n    var result = [];\r\n    var current = intervals[0];\r\n    for (var i = 1; i < intervals.length; i++) {\r\n        var next = intervals[i];\r\n        // If current is completely overlapped by second it is merged into it\r\n        if (current.end >= next.end) {\r\n            continue;\r\n            // Resolves partial overlaps by setting end of current to start of next\r\n        }\r\n        else if (start(next) < current.end) {\r\n            result.push(__assign({}, current, { end: start(next) }));\r\n            current = next;\r\n        }\r\n        else {\r\n            // No overlap, push onto results\r\n            result.push(current);\r\n            current = next;\r\n        }\r\n    }\r\n    result.push(current);\r\n    return result;\r\n};\r\n/**\r\n * Given two sets of intervals it merges them so the highIndexes set has priority\r\n *\r\n * @param highIndexes\r\n * @param lowIndexes\r\n *\r\n * @returns Interval array\r\n */\r\nvar combine = function (highIndexes, lowIndexes) {\r\n    var highIndex = 0;\r\n    var lowIndex = 0;\r\n    var merged = [];\r\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\r\n        var high = highIndexes[highIndex];\r\n        var low = lowIndexes[lowIndex];\r\n        // Only low priority left so push low onto results\r\n        if (highIndex === highIndexes.length) {\r\n            merged.push(__assign({}, low));\r\n            lowIndex++;\r\n            // Only high priority left so push high onto results\r\n        }\r\n        else if (lowIndex === lowIndexes.length) {\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // High priority start before or at same time as low\r\n        }\r\n        else if (start(high) <= start(low)) {\r\n            // No overlap between low and high\r\n            // low:                 ----------------------\r\n            // high: ---------------\r\n            if (high.end <= start(low)) {\r\n                // Partial overlap where high ends after low\r\n                // low:                 ----------------------\r\n                // high: ----------------------\r\n            }\r\n            else if (high.end < low.end) {\r\n                low.offsetStart = high.end - low.start;\r\n                // Low index completely overlapped, dismiss it\r\n                // low:               -----------\r\n                // high: -------------------------------------\r\n            }\r\n            else {\r\n                lowIndex++;\r\n            }\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // Low priority starts before high\r\n        }\r\n        else {\r\n            // No overlap between low and high intervals\r\n            // low: ---------------\r\n            // high                ----------------------\r\n            if (low.end <= start(high)) {\r\n                merged.push(__assign({}, low));\r\n                lowIndex++;\r\n                // Partial overlap where high ends after low\r\n                // low: ---------------------\r\n                // high                ----------------------\r\n            }\r\n            else if (high.end > low.end) {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                lowIndex++;\r\n                // Partial overlap where high ends before low\r\n                // low: -------------------------------------\r\n                // high             -----------\r\n            }\r\n            else {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                low.offsetStart = high.end - low.start;\r\n            }\r\n        }\r\n    }\r\n    return merged;\r\n};\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nvar cmp = function (a, b) {\r\n    if (a > b)\r\n        return +1;\r\n    if (a < b)\r\n        return -1;\r\n    return 0;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 10,\r\n    meterType: 'rms',\r\n    width: 300,\r\n    samplerate: 44100\r\n};\r\nexports.default = defaultOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(6);\r\nexports.WaveShaper = waveshaper_1.default;\r\nvar track_1 = __webpack_require__(0);\r\nexports.Track = track_1.default;\r\nvar managerconfig_1 = __webpack_require__(4);\r\nexports.defaultConfig = managerconfig_1.default;\r\nvar rms_1 = __webpack_require__(2);\r\nexports.rms = rms_1.default;\r\nvar peak_1 = __webpack_require__(1);\r\nexports.peak = peak_1.default;\r\nvar flatten_1 = __webpack_require__(3);\r\nexports.flatten = flatten_1.default;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar track_1 = __webpack_require__(0);\r\nvar managerconfig_1 = __webpack_require__(4);\r\n/**\r\n *\r\n *\r\n * @export\r\n */\r\nvar WaveShaper = /** @class */ (function () {\r\n    /**\r\n     * @param [options=defaultOptions] Initial options\r\n     * @throws Throws an error if samplerate is null or NaN\r\n     */\r\n    function WaveShaper(options) {\r\n        if (options === void 0) { options = managerconfig_1.default; }\r\n        /**\r\n         * Map of waveshapers managed by the manager\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.tracks = new Map();\r\n        /**\r\n         * Map of audio data\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.audioData = new Map();\r\n        /**\r\n         * @description Active id's, redraws when draw is called without argument\r\n         *\r\n         * @memberof WaveShaper\r\n         */\r\n        this.activeWaveShapers = [];\r\n        /**\r\n         * @description Map of callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.callbackMap = new Map();\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, managerconfig_1.default, options);\r\n    }\r\n    Object.defineProperty(WaveShaper.prototype, \"options\", {\r\n        /**\r\n         * @description Currect settings\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"lastProcessResult\", {\r\n        /**\r\n         * @description Last result of calling process, argument given to all callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._lastProcessResult; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"duration\", {\r\n        /**\r\n         * @description Total duration of all tracks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._duration; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     *\r\n     * @param id\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.flatten = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.getProcessIds.apply(this, ids).forEach(function (id) {\r\n            var waveShaper = _this.getTrack(id);\r\n            if (waveShaper != null)\r\n                waveShaper.flatten();\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Processes all relevant WaveShapers and invokes registered callbacks\r\n     *\r\n     * @param ids Options array of id's to draw\r\n     * @param forceDraw Force redraw of the given waves\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.process = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        var toProcess = this.getProcessIds.apply(this, ids);\r\n        var options = __assign({}, this.options);\r\n        var data = [];\r\n        for (var i = 0; i < toProcess.length; i++) {\r\n            var id = toProcess[i];\r\n            var wave = this.getTrack(id);\r\n            if (wave == null)\r\n                continue;\r\n            var peaks = wave.calculate(options, this.audioData);\r\n            data.push({ id: id, data: peaks });\r\n        }\r\n        // Invoke callbacks after returning value.\r\n        this._lastProcessResult = { options: options, data: data };\r\n        this.invokeCallbacks(this._lastProcessResult);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a callback that fires when the track with given id is processed\r\n     *\r\n     * @param id id of Track to register to\r\n     * @param callBack will be invoked when the given track is processed\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.on = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null) {\r\n            this.callbackMap.set(id, [callBack]);\r\n        }\r\n        else {\r\n            callbackArray.push(callBack);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters a callback from the given track, will no longer be called\r\n     *\r\n     * @param id id of Track to unregister from\r\n     * @param callBack callback to remove\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.off = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return this;\r\n        var index = callbackArray.indexOf(callBack);\r\n        if (index < 0)\r\n            return this;\r\n        callbackArray = callbackArray.splice(index, 1);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Merges the given options into the current and returns updated options\r\n     *\r\n     * @param options A (partial) ManagerOptions object\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setOptions = function (options) {\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, this.options, options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     *\r\n     * @param id id of WaveShaper\r\n     * @param segments Segments in wave\r\n     * @param color Background color of segments\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setTracks = function () {\r\n        var _this = this;\r\n        var tracks = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tracks[_i] = arguments[_i];\r\n        }\r\n        tracks.forEach(function (track) {\r\n            var foundWave = _this.getTrack(track.id);\r\n            if (foundWave == null) {\r\n                var wave = new track_1.default(track.id, track.intervals);\r\n                _this.tracks.set(track.id, wave);\r\n            }\r\n            else {\r\n                foundWave.intervals = track.intervals;\r\n                foundWave.flatten();\r\n            }\r\n        });\r\n        this._duration = this.getDuration();\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds audio data to the waveshaper and redraws waveshapers using it\r\n     *\r\n     * @param id  Data id, refered to by source parameter of segments\r\n     * @param data AudioBuffer with audio data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setData = function () {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            data[_i] = arguments[_i];\r\n        }\r\n        data.forEach(function (d) {\r\n            _this.audioData.set(d.id, d.data);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description The given id's are set as the active waveshapers, process only processes these when set,\r\n     * call with no values to allways process all values (default)\r\n     *\r\n     * @param ids Waveshaper id's to set as active\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setActive = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.activeWaveShapers = ids;\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Removes the waves and all callbacks with given id from the manager\r\n     *\r\n     * @param id\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.clearTracks = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        ids.forEach(function (id) {\r\n            _this.removeCallbacksById(id);\r\n            _this.tracks.delete(id);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Gets Track with given id\r\n     *\r\n     * @param id\r\n     * @returns Track with given ID\r\n     */\r\n    WaveShaper.prototype.getTrack = function (id) {\r\n        return this.tracks.get(id);\r\n    };\r\n    /**\r\n     * Validates given options\r\n     *\r\n     * @param options\r\n     * @returns true if valid, false if not\r\n     */\r\n    WaveShaper.prototype.optionsValid = function (options) {\r\n        return (options.samplesPerPixel === undefined || options.samplesPerPixel > 0) &&\r\n            (options.meterType === undefined || options.meterType) &&\r\n            (options.resolution === undefined || options.resolution > 0) &&\r\n            (options.width === undefined || options.width > 0) &&\r\n            (options.scrollPosition === undefined || options.scrollPosition >= 0) &&\r\n            (options.samplerate === undefined || options.samplerate > 0);\r\n    };\r\n    /**\r\n     * Invokes all registered callbacks registered to a waveshaper id in the data list\r\n     *\r\n     * @param options\r\n     * @param data\r\n     */\r\n    WaveShaper.prototype.invokeCallbacks = function (result) {\r\n        for (var i = 0; i < result.data.length; i++) {\r\n            var trackResult = result.data[i];\r\n            var callbacks = this.callbackMap.get(trackResult.id);\r\n            if (callbacks == null)\r\n                continue;\r\n            for (var j = 0; j < callbacks.length; j++) {\r\n                var callback = callbacks[j];\r\n                callback(result.options, new Float32Array(trackResult.data));\r\n            }\r\n        }\r\n    };\r\n    WaveShaper.prototype.getProcessIds = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        if (ids.length > 0)\r\n            return ids;\r\n        if (this.activeWaveShapers && this.activeWaveShapers.length > 0)\r\n            return this.activeWaveShapers;\r\n        return Array.from(this.tracks.keys());\r\n    };\r\n    WaveShaper.prototype.removeCallbacksById = function (id) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return;\r\n        callbackArray.splice(0, callbackArray.length);\r\n        this.callbackMap.delete(id);\r\n    };\r\n    /**\r\n     * @description Returns the maximum duration of all the waveshapers managed by this class\r\n     *\r\n     * @returns Maximum duration in seconds\r\n     * @memberof WaveShaper\r\n     */\r\n    WaveShaper.prototype.getDuration = function () {\r\n        return Array.from(this.tracks.values()).reduce(function (maxDuration, waveShaper) {\r\n            var duration = waveShaper.getDuration();\r\n            return duration > maxDuration ? duration : maxDuration;\r\n        }, 0);\r\n    };\r\n    return WaveShaper;\r\n}());\r\nexports.default = WaveShaper;\r\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=waveshaper.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/waveshaper/dist/waveshaper.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammerjs\",\"umd\":\"hammerjs\"}\n// module id = 1\n// module chunks = 0","import DomRenderWaveShaper from './core/domrender-waveshaper';\r\n\r\nexport default new DomRenderWaveShaper();\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import { WaveShaper } from \"waveshaper\";\r\nimport * as Hammer from \"hammerjs\";\r\n\r\nimport hammerConfig from '../config/hammerconfig';\r\nimport cut from '../interactions/cut';\r\nimport drag from '../interactions/drag';\r\nimport pan from '../interactions/pan';\r\nimport zoom from '../interactions/zoom';\r\nimport resize from '../interactions/resize';\r\nimport line from '../render/line';\r\nimport enter from '../interactions/enter';\r\nimport defaultDomOptions, { DomInput, DomOptions } from \"../config/dom-config\";\r\nimport { dragState } from \"../models/dragstate\";\r\n\r\n/**\r\n * Extends WaveShapeManager to allow for easy canvas rendering registration.\r\n * \r\n * @inheritDoc\r\n */\r\nexport default class DomRenderWaveShaper extends WaveShaper {\r\n    private unregister = () => {};\r\n\r\n    private unregisterMap = new Map<string, () => void>();\r\n    private canvasMap = new Map<string, () => void>();\r\n\r\n    public get scrollWidth(): number { return (this._duration * this._options.samplerate) / this._options.samplesPerPixel }\r\n\r\n    public get options(): DomOptions { return { ...this._options }; }\r\n    protected _options: DomOptions;\r\n\r\n    constructor(options: DomInput = defaultDomOptions) {\r\n        super(options);\r\n\r\n        this._options = { ...defaultDomOptions, ...this._options };\r\n    }\r\n\r\n    /**\r\n     * @description When a canvas is registered through this method each time the \r\n     * waveform is updated the canvas will be rerendered.\r\n     * \r\n     * It returns an unregister method, call to stop receiving callbacks.\r\n     * \r\n     * @param id WaveShaper id to register to.\r\n     * @param canvas Canvas to render to\r\n     * @param color Background color of segments\r\n     */\r\n    registerCanvas(id: string, canvas: HTMLCanvasElement, color: string): DomRenderWaveShaper {\r\n        const ctx = canvas.getContext('2d');\r\n        if(ctx == null) throw Error('Cannot get context from canvas.');\r\n\r\n        // Add classes and data attributes\r\n        canvas.classList.add('waveshaper');\r\n        canvas.setAttribute('data-wave-id', id);\r\n\r\n        canvas.style.width = this.options.width + 'px';\r\n        canvas.style.height = this.options.height + 'px';\r\n\r\n        const scale = (devicePixelRatio || 1) < 1 ? 1 : (devicePixelRatio || 1);\r\n\r\n        canvas.width = this.options.width * scale;\r\n        canvas.height = this.options.height;\r\n        \r\n        ctx.scale(scale, 1)\r\n\r\n        const callBack = (options: DomOptions, data: Float32Array) => line(data, options, ctx, color)\r\n        this.on(id, callBack);\r\n\r\n        this.unregisterCanvas(id);\r\n\r\n        \r\n        this.canvasMap.set(id, () => this.off(id, callBack));\r\n\r\n        const unregister = enter(this, canvas, dragState);\r\n        this.unregisterMap.set(id, unregister);\r\n\r\n        // If registerSetsActive is true \r\n        if(this._options.registerSetsActive) {\r\n            if(this.activeWaveShapers) this.setActive(...this.activeWaveShapers.concat(id));\r\n            else this.setActive(id);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clears the callbacks associated with this canvas\r\n     * \r\n     * @param id \r\n     * @returns Instance of WaveShaper\r\n     */\r\n    unregisterCanvas(id: string): DomRenderWaveShaper {\r\n        const unregister = this.canvasMap.get(id);\r\n        if(unregister != null) {\r\n            unregister();\r\n            this.canvasMap.delete(id);\r\n        }\r\n\r\n        const unregisterEvents = this.unregisterMap.get(id);\r\n        if(unregisterEvents != null) {\r\n            unregisterEvents();\r\n            this.unregisterMap.delete(id);\r\n        }\r\n\r\n        if(this._options.registerSetsActive) {\r\n            if(this.activeWaveShapers) {\r\n                const index = this.activeWaveShapers.indexOf(id);\r\n                if(index != -1) this.setActive(...this.activeWaveShapers.splice(index, 1))\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Loads and saves a set of url's to audio files.\r\n     * \r\n     * @param ctx \r\n     * @param data \r\n     */\r\n    loadData(ctx: AudioContext, ...data: { id: string, url: string }[]): DomRenderWaveShaper {\r\n        data.forEach(dat => {\r\n            fetch(dat.url)\r\n            .then(res => res.arrayBuffer())\r\n            .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))\r\n            .then(audioBuffer => {\r\n                this.setData({ id: dat.id, data: audioBuffer.getChannelData(0) }).process();\r\n            })\r\n            .catch(e => console.log(e));\r\n        });\r\n        \r\n        return this;\r\n    }\r\n\r\n    setInteraction(element: HTMLElement) {\r\n        if(element == null) throw Error('Interaction container element could not be found.');\r\n        this.unregister();\r\n\r\n        element.setAttribute('touch-action', 'none');\r\n        const hammer = new Hammer(element, hammerConfig);\r\n    \r\n        drag(this, hammer, dragState);\r\n        cut(this, hammer);\r\n        pan(this, hammer);\r\n        zoom(this, hammer);\r\n        resize(this, hammer);\r\n    \r\n        this.unregister = () => {\r\n            hammer.destroy();\r\n        };\r\n\r\n        return this;\r\n    }\r\n\r\n    clearInteraction() {\r\n        this.unregister();\r\n        this.unregister = () => { }\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/core/domrender-waveshaper.ts","import * as Hammer from 'hammerjs';\r\n\r\nconst hammerOptions: HammerOptions = {\r\n    touchAction : 'pan-y',\r\n    recognizers: [\r\n        [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }],\r\n        [Hammer.Pinch, { enable : true }],\r\n        [Hammer.Tap]\r\n    ]\r\n}\r\n\r\nexport default hammerOptions;\n\n\n// WEBPACK FOOTER //\n// ./src/config/hammerconfig.ts","import { Interval } from 'waveshaper';\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager) => {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'cut' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('tap', (ev: HammerInput) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(options == null || !shouldHandle(target, options))\r\n            return;\r\n\r\n        const id = target.getAttribute('data-wave-id');\r\n        if(id == null) return;\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = ev.target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n        if(interval == null) return;\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        const newSegment: Interval = { \r\n            ...segment, \r\n            offsetStart: time - segment.start,\r\n            id: options.generateId() \r\n        };\r\n\r\n        segment.end = time;\r\n        wave.intervals.push(newSegment);\r\n        \r\n        manager.flatten(wave.id);\r\n        manager.process(wave.id);\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/cut.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\nimport { DragState } from '../models/dragstate';\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager Waveshape Manager\r\n * @param hammer Hammer instance\r\n * @param container Container element\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager, dragState: DragState) => {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'drag' && target.hasAttribute('data-wave-id');\r\n\r\n    /**\r\n     * Sets up the drag by finding the \r\n     */\r\n    hammer.on('panstart', (ev: HammerInput) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n\r\n        const id = target.getAttribute('data-wave-id');\r\n        if(id == null) return;\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = ev.target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n\r\n        if (interval == null)\r\n            return;\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        dragState.options = options;\r\n\r\n        dragState.activeSegment = segment;\r\n        dragState.activeSegmentStart = dragState.activeSegment.start;\r\n        dragState.duration = segment.end - segment.start;\r\n\r\n        dragState.activeSegment.index = 1000;\r\n        dragState.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('panmove', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        if (dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n\r\n        if (dragState.dragging)\r\n            return;\r\n\r\n        dragState.dragging = true;\r\n\r\n        /** \r\n         * TODO below implementation stops all updates on touch devices on new track (tested on Samsung Galaxy s8),\r\n         * when dragged back to original keeps working. Works on desktop, it's a small performance improvement as\r\n         * it prevents a single track flatten + process when transferring a segment between tracks.\r\n         */\r\n\r\n        //// If the target has moved it is handled by the mouseHover function\r\n        // const id = ev.target.getAttribute('data-wave-id');\r\n        // if(id !== dragState.dragWave.id)\r\n        //     return;\r\n\r\n        const change = (ev.deltaX * dragState.options.samplesPerPixel) / dragState.options.samplerate;\r\n        let newTime = dragState.activeSegmentStart + change;\r\n\r\n        if (newTime + dragState.activeSegment.offsetStart < 0) {\r\n            newTime = -dragState.activeSegment.offsetStart;\r\n        }\r\n\r\n        dragState.activeSegment.start = newTime;\r\n        dragState.activeSegment.end = newTime + dragState.duration;\r\n\r\n        manager.flatten(dragState.dragWave.id);\r\n        manager.process(dragState.dragWave.id);\r\n\r\n        dragState.dragging = false;\r\n    });\r\n\r\n    hammer.on('panend', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        dragState.activeSegment = null;\r\n        dragState.activeSegmentStart = 0;\r\n        dragState.dragWave = null;\r\n        dragState.options = null;\r\n        dragState.duration = 0;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/drag.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface PanState {\r\n    panStart: number;\r\n    panMax: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst panState: PanState = {\r\n    panStart: 0,\r\n    panMax: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pan functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        panState.panMax = manager.scrollWidth + endMargin;\r\n        panState.panStart = options.scrollPosition;\r\n    });\r\n\r\n    hammer.on('panmove', (ev) =>  {\r\n        panState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n\r\n        if(!shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        const position = panState.panStart - ev.deltaX;\r\n        const newPosition = position > 0 ? position : 0;\r\n\r\n        // If it was and is still 0 no need to update\r\n        if(newPosition === panState.options.scrollPosition)\r\n            return;\r\n\r\n        if(position > panState.panMax - panState.options.width)\r\n            return;\r\n        \r\n        manager.setOptions({ scrollPosition: newPosition }).process();\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(panState.options == null || !shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        panState.options = null;\r\n        panState.panStart = 0;\r\n        panState.panMax = 0;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/pan.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface ZoomState {\r\n    maxWidth: number;\r\n    sppStart: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst zoomState: ZoomState = {\r\n    maxWidth: 0,\r\n    sppStart: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pinch zoom functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('pinchstart', (ev) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        zoomState.sppStart = options.samplesPerPixel;\r\n        zoomState.maxWidth = manager.scrollWidth + endMargin;\r\n    });\r\n\r\n    hammer.on('pinchmove', (ev) => {\r\n        zoomState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n\r\n        const sampleAtLeft = zoomState.options.scrollPosition * zoomState.options.samplesPerPixel;\r\n        const samplesInView = zoomState.options.width * zoomState.options.samplesPerPixel;\r\n        const samplesToCenter = samplesInView / 2;\r\n\r\n        const newSpp = zoomState.sppStart * ev.scale;\r\n\r\n        const newSamplesInView = zoomState.options.width * newSpp;\r\n        const newSamplesToCenter = newSamplesInView / 2;\r\n\r\n        const maxWidth = manager.scrollWidth + endMargin;\r\n        const maxSamplesInView = maxWidth  * zoomState.options.samplerate;\r\n\r\n        if(newSamplesInView >= maxSamplesInView)\r\n            return;\r\n\r\n        const newScroll = (sampleAtLeft + samplesToCenter - newSamplesToCenter) / newSpp;\r\n\r\n        manager.setOptions({\r\n            samplesPerPixel: newSpp,\r\n            scrollPosition: newScroll >= 0 ? newScroll : 0\r\n        }).process();\r\n    });\r\n\r\n    hammer.on('pinchend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n\r\n        zoomState.sppStart = 0;\r\n        zoomState.maxWidth = 0;\r\n        zoomState.options = null;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/zoom.ts","import { Interval, Track } from 'waveshaper';\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\ndeclare type SegmentSide = 'left' | 'right';\r\n\r\ninterface ResizeState {\r\n    activeSegment: Interval | null;\r\n    activeSegmentSide: SegmentSide | null;\r\n    activeSegmentOffsetStart: number;\r\n    activeSegmentOffsetEnd: number;\r\n    dragWave: Track | null;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst resizeState: ResizeState = {\r\n    activeSegment: null,\r\n    activeSegmentSide: null,\r\n    activeSegmentOffsetStart: 0,\r\n    activeSegmentOffsetEnd: 0,\r\n    dragWave: null,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'resize' && target != null && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        const id = target.getAttribute('data-wave-id');\r\n        if(id == null) return;\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = ev.target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * options.samplesPerPixel / options.samplerate;\r\n\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n\r\n        if(interval == null) \r\n            return;\r\n\r\n        resizeState.activeSegmentSide = \r\n            time < interval.start + interval.offsetStart + ((interval.end - (interval.start + interval.offsetStart)) / 2) ? \r\n                'left' : \r\n                'right';\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        resizeState.options = options;\r\n        resizeState.activeSegment = segment;\r\n\r\n        resizeState.activeSegmentOffsetStart = segment.offsetStart;\r\n        resizeState.activeSegmentOffsetEnd = segment.end;\r\n\r\n        segment.index = 1000;\r\n        resizeState.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('panmove', (ev) =>  {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(resizeState.dragWave == null || resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n\r\n        const options = manager.options;\r\n            \r\n        if(resizeState.activeSegment == null)\r\n            return;\r\n\r\n        const change = (ev.deltaX * options.samplesPerPixel) / options.samplerate;\r\n        let newTime = resizeState.activeSegmentSide === 'left' ?\r\n            resizeState.activeSegmentOffsetStart + change :\r\n            resizeState.activeSegmentOffsetEnd + change;\r\n\r\n        // Don't allow offset to become less than 0\r\n        if(newTime < 0) {\r\n            newTime = 0;\r\n        }\r\n\r\n        const active = resizeState.activeSegment;\r\n        const newDuration = resizeState.activeSegmentSide === 'left' ?\r\n            active.end - active.start - newTime :\r\n            newTime - active.start - active.offsetStart;\r\n\r\n        // Do not allow resizing \r\n        if(newDuration <= 2) {\r\n            return;\r\n        }\r\n        \r\n        resizeState.activeSegmentSide === 'left' ?\r\n            active.offsetStart = newTime :\r\n            active.end = newTime;\r\n\r\n        manager.flatten(resizeState.dragWave.id);\r\n        manager.process(resizeState.dragWave.id);\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n\r\n        resizeState.activeSegment = null;\r\n        resizeState.activeSegmentOffsetStart = 0;\r\n        resizeState.activeSegmentOffsetEnd = 0;\r\n        resizeState.activeSegmentSide = null;\r\n        resizeState.dragWave = null;\r\n        resizeState.options = null;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/resize.ts","import { DomOptions } from \"../config/dom-config\";\r\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param waveform Sampled data for each pixel, max at 0, min at 1 \r\n * @param options\r\n * @param ctx \r\n * @param color\r\n */\r\nexport default (waveform: Float32Array, options: DomOptions, ctx: CanvasRenderingContext2D, color: string) => {\r\n    const scale = options.height / 2;\r\n    const width = options.width;\r\n    \r\n    ctx.fillStyle = color;\r\n    ctx.clearRect(0, 0, width, options.height);\r\n    \r\n    for(let i = 0, inSegment = false, segmentStart = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        const pointInSegment = waveform[index + 3] === 1;\r\n        if(!inSegment && pointInSegment) {\r\n            inSegment = true;\r\n            segmentStart = i;\r\n        } else if (inSegment && (!pointInSegment || i === width - 1)) {\r\n            inSegment = false;\r\n            ctx.fillRect(segmentStart, 0, i - segmentStart, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fillStyle = 'black';\r\n    ctx.beginPath();\r\n    \r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n\r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index + 1] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.closePath();\r\n\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        if(waveform[index - 4 + 2] === 0 && waveform[index + 2] === 1) {\r\n            ctx.rect(i, 0, 1, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fill();\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/render/line.ts","import { DragState } from \"../models/dragstate\";\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\n\r\nexport default (manager: DomRenderWaveShaper,canvas: HTMLCanvasElement, dragState: DragState): () => void => {\r\n\r\n    const enterlistener = (ev: PointerEvent) => pointerEnter(ev);\r\n    const downlistener = (ev: PointerEvent) => canvas.releasePointerCapture(ev.pointerId);\r\n\r\n\r\n    /**\r\n     * Fires when the mouse moves over the container,\r\n     * If a segment is being dragged and the pointer moves\r\n     * into another canvas the segment is tranfered to the \r\n     * new canvas.\r\n     */\r\n    canvas.addEventListener('pointerenter', enterlistener);\r\n    canvas.addEventListener('pointerdown', downlistener);\r\n\r\n    const destroy = () => {\r\n        canvas.removeEventListener('pointerenter', enterlistener);\r\n        canvas.removeEventListener('pointerdown', downlistener);\r\n    }\r\n\r\n    const pointerEnter = (ev: PointerEvent) => {\r\n        if (dragState.options == null || dragState.options.mode !== 'drag')\r\n            return;\r\n\r\n        if (dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n\r\n        const canvas = dragState.options.getEventTarget(ev);\r\n        if (canvas == null || !(canvas instanceof HTMLCanvasElement))\r\n            return;\r\n\r\n        const id = canvas.getAttribute('data-wave-id');\r\n        if (id == null) return;\r\n\r\n        const wave = manager.getTrack(id);\r\n        if (wave == null) return;\r\n\r\n        if (dragState.dragWave.id !== id) {\r\n            const index = dragState.dragWave.intervals.indexOf(dragState.activeSegment);\r\n            dragState.dragWave.intervals.splice(index, 1);\r\n\r\n            wave.intervals.push(dragState.activeSegment);\r\n            dragState.activeSegment.index = 1000;\r\n\r\n            const currentId = dragState.dragWave.id;\r\n            dragState.dragWave = wave;\r\n\r\n            manager.flatten(wave.id, currentId);\r\n            manager.process(wave.id, currentId);\r\n        }\r\n    }\r\n\r\n    return destroy;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/enter.ts","import { defaultConfig, ManagerOptions, ManagerInput } from \"waveshaper\";\r\n\r\nexport type InteractionMode = 'pan' | 'drag' | 'cut' | 'resize';\r\nexport type GenerateId = () => string;\r\nexport type GetTarget = (ev: Event) => HTMLElement;\r\n\r\n\r\nexport interface DomOptions extends ManagerOptions {\r\n    getEventTarget: GetTarget;\r\n    registerSetsActive: boolean;\r\n    height: number;\r\n    generateId: GenerateId;\r\n    mode: InteractionMode;\r\n}\r\n\r\nexport interface DomInput extends ManagerInput {\r\n    getEventTarget?: GetTarget;\r\n    registerSetsActive?: boolean;\r\n    height?: number;\r\n    generateId?: GenerateId;\r\n    mode?: InteractionMode;\r\n}\r\n\r\nconst defaultDomOptions: DomOptions = {\r\n    ...defaultConfig,\r\n    mode: 'pan',\r\n    height: 150,\r\n    getEventTarget: (ev) => <HTMLElement>ev.target,\r\n    generateId: () => Math.random().toString(),\r\n    registerSetsActive: true \r\n}\r\n\r\nexport default defaultDomOptions;\n\n\n// WEBPACK FOOTER //\n// ./src/config/dom-config.ts","import { Interval, Track } from \"waveshaper\";\r\nimport { DomOptions } from \"../config/dom-config\";\r\n\r\nexport interface DragState {\r\n    activeSegment: Interval | null;\r\n    activeSegmentStart: number;\r\n    dragWave: Track | null;\r\n    options: DomOptions | null;\r\n    duration: number;\r\n    dragging: boolean;\r\n}\r\n\r\nexport const dragState: DragState = {\r\n    activeSegment: null,\r\n    activeSegmentStart: 0,\r\n    dragWave: null,\r\n    options: null,\r\n    duration: 0,\r\n    dragging: false\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/models/dragstate.ts"],"sourceRoot":""}