{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///waveshaper-dom.min.js","webpack:///webpack/bootstrap 2ab2eb7b1450a0f7daa1","webpack:///./node_modules/waveshaper/dist/waveshaper.js","webpack:///external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammerjs\",\"umd\":\"hammerjs\"}","webpack:///./src/index.ts","webpack:///./src/core/domrender-waveshaper.ts","webpack:///./src/config/hammerconfig.ts","webpack:///./src/interactions/cut.ts","webpack:///./src/interactions/drag.ts","webpack:///./src/interactions/pan.ts","webpack:///./src/interactions/zoom.ts","webpack:///./src/interactions/resize.ts","webpack:///./src/render/line.ts","webpack:///./src/interactions/enter.ts","webpack:///./src/config/dom-config.ts","webpack:///./src/models/dragstate.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","peak_1","rms_1","flatten_1","Track","id","intervals","_flattened","default","slice","flatten","getDuration","Math","max","apply","map","end","calculate","options","dataMap","meterType","flattened","sampleSize","ceil","samplesPerPixel","resolution","start","scrollPosition","startSecond","samplerate","secondsPerPixel","endSecond","width","peaks","Float32Array","currentIntervalIndex","findIndex","offsetStart","maxIntervalIncrementIndex","length","currentInterval","buffer","source","currentSecond","startBorder","endBorder","intervalBorder","secondsIntoInterval","startSample","floor","endSample","length_1","loopEnd","min","j","sample","set","posSum","negSum","count","val","sqrt","__assign","assign","t","arguments","segment","segments","sorted","sort","normalized","normalizeIndex","copied","copy","grouped","groupByIndex","weightedMerge","index","preNormalizeIndex","Number","MIN_SAFE_INTEGER","forEach","el","a","b","cmp","reduce","groups","interval","push","_i","_a","keys","merged","merge","combine","result","current","next","highIndexes","lowIndexes","highIndex","lowIndex","high","low","defaultOptions","waveshaper_1","WaveShaper","track_1","managerconfig_1","defaultConfig","rms","peak","tracks","Map","audioData","callbackMap","_activeWaveShapers","optionsValid","Error","JSON","stringify","_options","_lastProcessResult","_duration","timeToPosition","time","positionToTime","position","_this","ids","getProcessIds","waveShaper","getTrack","process","toProcess","data","wave","invokeCallbacks","on","callBack","callbackArray","off","indexOf","splice","setOptions","setTracks","track","foundWave","setData","setActive","clearTracks","removeCallbacksById","delete","undefined","trackResult","callbacks","callback","Array","from","values","maxDuration","duration","domrender_waveshaper_1","DomRenderWaveShaper","__extends","extendStatics","setPrototypeOf","__proto__","__","constructor","create","Hammer","hammerconfig_1","cut_1","drag_1","pan_1","zoom_1","resize_1","line_1","enter_1","dom_config_1","dragstate_1","_super","unregister","unregisterMap","canvasMap","_hammer","input","registerCanvas","canvas","color","ctx","getContext","classList","add","setAttribute","style","height","scale","devicePixelRatio","unregisterCanvas","dragState","registerSetsActive","activeWaveShapers","concat","unregisterEvents","loadData","dat","fetch","url","then","res","arrayBuffer","decodeAudioData","audioBuffer","getChannelData","catch","e","console","log","setInteraction","element","hammer","destroy","clearInteraction","hammerOptions","touchAction","recognizers","Pan","direction","DIRECTION_HORIZONTAL","Pinch","enable","Tap","manager","shouldHandle","target","mode","hasAttribute","ev","getEventTarget","srcEvent","getAttribute","bb","getBoundingClientRect","center","x","left","find","newSegment","generateId","activeSegment","activeSegmentStart","dragWave","dragging","change","deltaX","newTime","default_1","panState","panMax","scrollWidth","endMargin","panStart","newPosition","zoomState","sppStart","maxWidth","sampleAtLeft","samplesInView","samplesToCenter","newSpp","newSamplesInView","newSamplesToCenter","newScroll","resizeState","activeSegmentSide","activeSegmentOffsetStart","activeSegmentOffsetEnd","active","waveform","fillStyle","clearRect","inSegment","segmentStart","pointInSegment","fillRect","beginPath","moveTo","lineTo","round","closePath","rect","fill","enterlistener","pointerEnter","downlistener","releasePointerCapture","pointerId","addEventListener","HTMLCanvasElement","currentId","removeEventListener","defaultDomOptions","random","toString"],"mappings":"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","file":"waveshaper-dom.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hammerjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hammerjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WS\"] = factory(require(\"hammerjs\"));\n\telse\n\t\troot[\"WS\"] = factory(root[\"Hammer\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hammerjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hammerjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WS\"] = factory(require(\"hammerjs\"));\n\telse\n\t\troot[\"WS\"] = factory(root[\"Hammer\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waveshaper\"] = factory();\n\telse\n\t\troot[\"waveshaper\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar peak_1 = __webpack_require__(1);\r\nvar rms_1 = __webpack_require__(2);\r\nvar flatten_1 = __webpack_require__(3);\r\nvar Track = /** @class */ (function () {\r\n    function Track(id, intervals) {\r\n        this.id = id;\r\n        this.intervals = intervals || [];\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    }\r\n    Object.defineProperty(Track.prototype, \"flattened\", {\r\n        get: function () { return this._flattened.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Track.prototype.flatten = function () {\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    };\r\n    /**\r\n     * Gets the duration of the audio in seconds\r\n     *\r\n     * @returns Decimal value of total duration in seconds\r\n     */\r\n    Track.prototype.getDuration = function () {\r\n        return Math.max.apply(Math, this.intervals.map(function (s) { return s.end; }));\r\n    };\r\n    /**\r\n     * Gets the summerized values for the current settings\r\n     *\r\n     * @param options\r\n     * @param dataMap\r\n     * @returns Two dimensional array, one entry for each pixel, for each pixel a min\r\n     * and a max value.\r\n     */\r\n    Track.prototype.calculate = function (options, dataMap) {\r\n        switch (options.meterType) {\r\n            case 'peak':\r\n                return peak_1.default(options, this.flattened, dataMap);\r\n            default:\r\n                return rms_1.default(options, this.flattened, dataMap);\r\n        }\r\n    };\r\n    return Track;\r\n}());\r\nexports.default = Track;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates peak values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var min = 0, max = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize) {\r\n            var sample = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (sample > max)\r\n                max = sample;\r\n            else if (sample < min)\r\n                min = sample;\r\n        }\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculate rms values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var posSum = 0, negSum = 0, count = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize, count++) {\r\n            var val = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (val > 0) {\r\n                posSum += val * val;\r\n            }\r\n            else {\r\n                negSum += val * val;\r\n            }\r\n        }\r\n        var min = -Math.sqrt(negSum / count);\r\n        var max = Math.sqrt(posSum / count);\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar start = function (segment) { return segment.start + segment.offsetStart; };\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param segments Segments to flatten\r\n * @returns flattened Interval array\r\n */\r\nexports.default = (function (segments) {\r\n    if (segments == null || segments.length === 0)\r\n        return [];\r\n    var sorted = sort(segments);\r\n    var normalized = normalizeIndex(sorted);\r\n    var copied = copy(normalized);\r\n    var grouped = groupByIndex(copied);\r\n    return weightedMerge(grouped);\r\n});\r\n/**\r\n * Copies elements so original are unaltered\r\n *\r\n * @param intervals\r\n */\r\nvar copy = function (intervals) { return intervals.map(function (i) { return (__assign({}, i)); }); };\r\n/**\r\n * When an element is altered the index is set very high,\r\n * this functions normalizes to indexes back to 0\r\n *\r\n * @param segments\r\n */\r\nvar normalizeIndex = function (segments) {\r\n    var index = 0;\r\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\r\n    segments.forEach(function (el) {\r\n        if (el.index > preNormalizeIndex) {\r\n            preNormalizeIndex = el.index;\r\n            el.index = ++index;\r\n        }\r\n        else {\r\n            el.index = index;\r\n        }\r\n    });\r\n    return segments;\r\n};\r\n/**\r\n * Sorts the intervals by index, then by start\r\n *\r\n * @param intervals\r\n * @return Interval array\r\n */\r\nvar sort = function (intervals) {\r\n    return intervals.sort(function (a, b) { return cmp(a.index, b.index) || cmp(start(a), start(b)); });\r\n};\r\n/**\r\n * Returns a map of intervals grouped by the key property\r\n *\r\n * @param intervals\r\n * @param key\r\n *\r\n * @returns Map of index => interval[]\r\n */\r\nvar groupByIndex = function (intervals) {\r\n    return intervals.reduce(function (groups, interval) {\r\n        (groups[interval.index] = groups[interval.index] || []).push(interval);\r\n        return groups;\r\n    }, {});\r\n};\r\n/**\r\n * Merges all the groups by index\r\n *\r\n * @param grouped\r\n * @returns Interval array\r\n */\r\nvar weightedMerge = function (grouped) {\r\n    var flattened = null;\r\n    for (var _i = 0, _a = Object.keys(grouped); _i < _a.length; _i++) {\r\n        var index = _a[_i];\r\n        var merged = merge(grouped[index]);\r\n        if (flattened == null) {\r\n            flattened = merged;\r\n        }\r\n        else {\r\n            flattened = combine(merged, flattened);\r\n        }\r\n    }\r\n    return flattened;\r\n};\r\n/**\r\n * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n *\r\n * @param intervals\r\n * @returns Interval array\r\n */\r\nvar merge = function (intervals) {\r\n    if (intervals.length <= 1)\r\n        return intervals;\r\n    var result = [];\r\n    var current = intervals[0];\r\n    for (var i = 1; i < intervals.length; i++) {\r\n        var next = intervals[i];\r\n        // If current is completely overlapped by second it is merged into it\r\n        if (current.end >= next.end) {\r\n            continue;\r\n            // Resolves partial overlaps by setting end of current to start of next\r\n        }\r\n        else if (start(next) < current.end) {\r\n            result.push(__assign({}, current, { end: start(next) }));\r\n            current = next;\r\n        }\r\n        else {\r\n            // No overlap, push onto results\r\n            result.push(current);\r\n            current = next;\r\n        }\r\n    }\r\n    result.push(current);\r\n    return result;\r\n};\r\n/**\r\n * Given two sets of intervals it merges them so the highIndexes set has priority\r\n *\r\n * @param highIndexes\r\n * @param lowIndexes\r\n *\r\n * @returns Interval array\r\n */\r\nvar combine = function (highIndexes, lowIndexes) {\r\n    var highIndex = 0;\r\n    var lowIndex = 0;\r\n    var merged = [];\r\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\r\n        var high = highIndexes[highIndex];\r\n        var low = lowIndexes[lowIndex];\r\n        // Only low priority left so push low onto results\r\n        if (highIndex === highIndexes.length) {\r\n            merged.push(__assign({}, low));\r\n            lowIndex++;\r\n            // Only high priority left so push high onto results\r\n        }\r\n        else if (lowIndex === lowIndexes.length) {\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // High priority start before or at same time as low\r\n        }\r\n        else if (start(high) <= start(low)) {\r\n            // No overlap between low and high\r\n            // low:                 ----------------------\r\n            // high: ---------------\r\n            if (high.end <= start(low)) {\r\n                // Partial overlap where high ends after low\r\n                // low:                 ----------------------\r\n                // high: ----------------------\r\n            }\r\n            else if (high.end < low.end) {\r\n                low.offsetStart = high.end - low.start;\r\n                // Low index completely overlapped, dismiss it\r\n                // low:               -----------\r\n                // high: -------------------------------------\r\n            }\r\n            else {\r\n                lowIndex++;\r\n            }\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // Low priority starts before high\r\n        }\r\n        else {\r\n            // No overlap between low and high intervals\r\n            // low: ---------------\r\n            // high                ----------------------\r\n            if (low.end <= start(high)) {\r\n                merged.push(__assign({}, low));\r\n                lowIndex++;\r\n                // Partial overlap where high ends after low\r\n                // low: ---------------------\r\n                // high                ----------------------\r\n            }\r\n            else if (high.end > low.end) {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                lowIndex++;\r\n                // Partial overlap where high ends before low\r\n                // low: -------------------------------------\r\n                // high             -----------\r\n            }\r\n            else {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                low.offsetStart = high.end - low.start;\r\n            }\r\n        }\r\n    }\r\n    return merged;\r\n};\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nvar cmp = function (a, b) {\r\n    if (a > b)\r\n        return +1;\r\n    if (a < b)\r\n        return -1;\r\n    return 0;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 10,\r\n    meterType: 'rms',\r\n    width: 300,\r\n    samplerate: 44100\r\n};\r\nexports.default = defaultOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(6);\r\nexports.WaveShaper = waveshaper_1.default;\r\nvar track_1 = __webpack_require__(0);\r\nexports.Track = track_1.default;\r\nvar managerconfig_1 = __webpack_require__(4);\r\nexports.defaultConfig = managerconfig_1.default;\r\nvar rms_1 = __webpack_require__(2);\r\nexports.rms = rms_1.default;\r\nvar peak_1 = __webpack_require__(1);\r\nexports.peak = peak_1.default;\r\nvar flatten_1 = __webpack_require__(3);\r\nexports.flatten = flatten_1.default;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar track_1 = __webpack_require__(0);\r\nvar managerconfig_1 = __webpack_require__(4);\r\n/**\r\n *\r\n *\r\n * @export\r\n */\r\nvar WaveShaper = /** @class */ (function () {\r\n    /**\r\n     * @param [options=defaultOptions] Initial options\r\n     * @throws Throws an error if samplerate is null or NaN\r\n     */\r\n    function WaveShaper(options) {\r\n        if (options === void 0) { options = managerconfig_1.default; }\r\n        /**\r\n         * Map of waveshapers managed by the manager\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.tracks = new Map();\r\n        /**\r\n         * Map of audio data\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.audioData = new Map();\r\n        /**\r\n         * @description Map of callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.callbackMap = new Map();\r\n        this._activeWaveShapers = [];\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, managerconfig_1.default, options);\r\n    }\r\n    Object.defineProperty(WaveShaper.prototype, \"options\", {\r\n        /**\r\n         * @description Currect settings\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"activeWaveShapers\", {\r\n        /**\r\n         * @description Active id's, redraws when draw is called without argument\r\n         *\r\n         * @readonly\r\n         * @unused\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._activeWaveShapers.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"lastProcessResult\", {\r\n        /**\r\n         * @description Last result of calling process, argument given to all callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._lastProcessResult; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"duration\", {\r\n        /**\r\n         * @description Total duration of all tracks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._duration; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gives the position corresponding to a given time\r\n     *\r\n     * @param time\r\n     */\r\n    WaveShaper.prototype.timeToPosition = function (time) {\r\n        return (time * this._options.samplerate) / this._options.samplesPerPixel;\r\n    };\r\n    /**\r\n     * Gives the time corresponding to a given position\r\n     * @param position\r\n     */\r\n    WaveShaper.prototype.positionToTime = function (position) {\r\n        return (position * this._options.samplesPerPixel) / this._options.samplerate;\r\n    };\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     *\r\n     * @param id\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.flatten = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.getProcessIds.apply(this, ids).forEach(function (id) {\r\n            var waveShaper = _this.getTrack(id);\r\n            if (waveShaper != null)\r\n                waveShaper.flatten();\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Processes all relevant WaveShapers and invokes registered callbacks\r\n     *\r\n     * @param ids Options array of id's to draw\r\n     * @param forceDraw Force redraw of the given waves\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.process = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        var toProcess = this.getProcessIds.apply(this, ids);\r\n        var options = __assign({}, this.options);\r\n        var data = [];\r\n        for (var i = 0; i < toProcess.length; i++) {\r\n            var id = toProcess[i];\r\n            var wave = this.getTrack(id);\r\n            if (wave == null)\r\n                continue;\r\n            var peaks = wave.calculate(options, this.audioData);\r\n            data.push({ id: id, data: peaks });\r\n        }\r\n        // Invoke callbacks after returning value.\r\n        this._lastProcessResult = { options: options, data: data };\r\n        this.invokeCallbacks(this._lastProcessResult);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a callback that fires when the track with given id is processed\r\n     *\r\n     * @param id id of Track to register to\r\n     * @param callBack will be invoked when the given track is processed\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.on = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null) {\r\n            this.callbackMap.set(id, [callBack]);\r\n        }\r\n        else {\r\n            callbackArray.push(callBack);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters a callback from the given track, will no longer be called\r\n     *\r\n     * @param id id of Track to unregister from\r\n     * @param callBack callback to remove\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.off = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return this;\r\n        var index = callbackArray.indexOf(callBack);\r\n        if (index < 0)\r\n            return this;\r\n        callbackArray = callbackArray.splice(index, 1);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Merges the given options into the current and returns updated options\r\n     *\r\n     * @param options A (partial) ManagerOptions object\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setOptions = function (options) {\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, this.options, options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     *\r\n     * @param id id of WaveShaper\r\n     * @param segments Segments in wave\r\n     * @param color Background color of segments\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setTracks = function () {\r\n        var tracks = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tracks[_i] = arguments[_i];\r\n        }\r\n        for (var i = 0; i < tracks.length; i++) {\r\n            var track = tracks[i];\r\n            var foundWave = this.getTrack(track.id);\r\n            if (foundWave == null) {\r\n                var wave = new track_1.default(track.id, track.intervals);\r\n                this.tracks.set(track.id, wave);\r\n            }\r\n            else {\r\n                foundWave.intervals = track.intervals || [];\r\n                foundWave.flatten();\r\n            }\r\n        }\r\n        this._duration = this.getDuration();\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds audio data to the waveshaper and redraws waveshapers using it\r\n     *\r\n     * @param id  Data id, refered to by source parameter of segments\r\n     * @param data AudioBuffer with audio data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setData = function () {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            data[_i] = arguments[_i];\r\n        }\r\n        data.forEach(function (d) {\r\n            _this.audioData.set(d.id, d.data);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description The given id's are set as the active waveshapers, process only processes these when set,\r\n     * call with no values to allways process all values (default)\r\n     *\r\n     * @param ids Waveshaper id's to set as active\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setActive = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this._activeWaveShapers = ids;\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Removes the waves and all callbacks with given id from the manager\r\n     *\r\n     * @param id\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.clearTracks = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        ids.forEach(function (id) {\r\n            _this.removeCallbacksById(id);\r\n            _this.tracks.delete(id);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Gets Track with given id\r\n     *\r\n     * @param id\r\n     * @returns Track with given ID\r\n     */\r\n    WaveShaper.prototype.getTrack = function (id) {\r\n        return this.tracks.get(id);\r\n    };\r\n    /**\r\n     * Validates given options\r\n     *\r\n     * @param options\r\n     * @returns true if valid, false if not\r\n     */\r\n    WaveShaper.prototype.optionsValid = function (options) {\r\n        return (options.samplesPerPixel === undefined || options.samplesPerPixel > 0) &&\r\n            (options.meterType === undefined || options.meterType) &&\r\n            (options.resolution === undefined || options.resolution > 0) &&\r\n            (options.width === undefined || options.width > 0) &&\r\n            (options.scrollPosition === undefined || options.scrollPosition >= 0) &&\r\n            (options.samplerate === undefined || options.samplerate > 0);\r\n    };\r\n    /**\r\n     * Invokes all registered callbacks registered to a waveshaper id in the data list\r\n     *\r\n     * @param options\r\n     * @param data\r\n     */\r\n    WaveShaper.prototype.invokeCallbacks = function (result) {\r\n        for (var i = 0; i < result.data.length; i++) {\r\n            var trackResult = result.data[i];\r\n            var callbacks = this.callbackMap.get(trackResult.id);\r\n            if (callbacks == null)\r\n                continue;\r\n            for (var j = 0; j < callbacks.length; j++) {\r\n                var callback = callbacks[j];\r\n                callback(result.options, new Float32Array(trackResult.data));\r\n            }\r\n        }\r\n    };\r\n    WaveShaper.prototype.getProcessIds = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        if (ids.length > 0)\r\n            return ids;\r\n        if (this._activeWaveShapers.length > 0)\r\n            return this._activeWaveShapers;\r\n        return Array.from(this.tracks.keys());\r\n    };\r\n    WaveShaper.prototype.removeCallbacksById = function (id) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return;\r\n        callbackArray.splice(0, callbackArray.length);\r\n        this.callbackMap.delete(id);\r\n    };\r\n    /**\r\n     * @description Returns the maximum duration of all the waveshapers managed by this class\r\n     *\r\n     * @returns Maximum duration in seconds\r\n     * @memberof WaveShaper\r\n     */\r\n    WaveShaper.prototype.getDuration = function () {\r\n        return Array.from(this.tracks.values()).reduce(function (maxDuration, waveShaper) {\r\n            var duration = waveShaper.getDuration();\r\n            return duration > maxDuration ? duration : maxDuration;\r\n        }, 0);\r\n    };\r\n    return WaveShaper;\r\n}());\r\nexports.default = WaveShaper;\r\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=waveshaper.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar domrender_waveshaper_1 = __webpack_require__(3);\r\nexports.DomRenderWaveShaper = domrender_waveshaper_1.default;\r\nexports.default = new domrender_waveshaper_1.default();\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(0);\r\nvar Hammer = __webpack_require__(1);\r\nvar hammerconfig_1 = __webpack_require__(4);\r\nvar cut_1 = __webpack_require__(5);\r\nvar drag_1 = __webpack_require__(6);\r\nvar pan_1 = __webpack_require__(7);\r\nvar zoom_1 = __webpack_require__(8);\r\nvar resize_1 = __webpack_require__(9);\r\nvar line_1 = __webpack_require__(10);\r\nvar enter_1 = __webpack_require__(11);\r\nvar dom_config_1 = __webpack_require__(12);\r\nvar dragstate_1 = __webpack_require__(13);\r\n/**\r\n * Extends WaveShapeManager to allow for easy canvas rendering registration.\r\n *\r\n * @inheritDoc\r\n */\r\nvar DomRenderWaveShaper = /** @class */ (function (_super) {\r\n    __extends(DomRenderWaveShaper, _super);\r\n    function DomRenderWaveShaper(options) {\r\n        if (options === void 0) { options = dom_config_1.default; }\r\n        var _this = _super.call(this, options) || this;\r\n        _this.unregister = function () { };\r\n        _this.unregisterMap = new Map();\r\n        _this.canvasMap = new Map();\r\n        _this._options = __assign({}, dom_config_1.default, _this._options);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"scrollWidth\", {\r\n        get: function () { return (this._duration * this._options.samplerate) / this._options.samplesPerPixel; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"options\", {\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DomRenderWaveShaper.prototype, \"hammer\", {\r\n        get: function () { return this._hammer; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DomRenderWaveShaper.prototype.setOptions = function (input) {\r\n        this._options = __assign({}, this._options, input);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description When a canvas is registered through this method each time the\r\n     * waveform is updated the canvas will be rerendered.\r\n     *\r\n     * It returns an unregister method, call to stop receiving callbacks.\r\n     *\r\n     * @param id WaveShaper id to register to.\r\n     * @param canvas Canvas to render to\r\n     * @param color Background color of segments\r\n     */\r\n    DomRenderWaveShaper.prototype.registerCanvas = function (id, canvas, color) {\r\n        var _this = this;\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx == null)\r\n            throw Error('Cannot get context from canvas.');\r\n        // Add classes and data attributes\r\n        canvas.classList.add('waveshaper');\r\n        canvas.setAttribute('data-wave-id', id);\r\n        canvas.style.width = this.options.width + 'px';\r\n        canvas.style.height = this.options.height + 'px';\r\n        var scale = (devicePixelRatio || 1) < 1 ? 1 : (devicePixelRatio || 1);\r\n        canvas.width = this.options.width * scale;\r\n        canvas.height = this.options.height;\r\n        ctx.scale(scale, 1);\r\n        var callBack = function (options, data) { return line_1.default(data, options, ctx, color); };\r\n        this.on(id, callBack);\r\n        this.unregisterCanvas(id);\r\n        this.canvasMap.set(id, function () { return _this.off(id, callBack); });\r\n        var unregister = enter_1.default(this, canvas, dragstate_1.dragState);\r\n        this.unregisterMap.set(id, unregister);\r\n        // If registerSetsActive is true \r\n        if (this._options.registerSetsActive) {\r\n            this.setActive.apply(this, this.activeWaveShapers.concat(id));\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Clears the callbacks associated with this canvas\r\n     *\r\n     * @param id\r\n     * @returns Instance of WaveShaper\r\n     */\r\n    DomRenderWaveShaper.prototype.unregisterCanvas = function (id) {\r\n        var unregister = this.canvasMap.get(id);\r\n        if (unregister != null) {\r\n            unregister();\r\n            this.canvasMap.delete(id);\r\n        }\r\n        var unregisterEvents = this.unregisterMap.get(id);\r\n        if (unregisterEvents != null) {\r\n            unregisterEvents();\r\n            this.unregisterMap.delete(id);\r\n        }\r\n        if (this._options.registerSetsActive) {\r\n            var index = this.activeWaveShapers.indexOf(id);\r\n            if (index != -1)\r\n                this.setActive.apply(this, this.activeWaveShapers.splice(index, 1));\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Loads and saves a set of url's to audio files.\r\n     *\r\n     * @param ctx\r\n     * @param data\r\n     */\r\n    DomRenderWaveShaper.prototype.loadData = function (ctx) {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            data[_i - 1] = arguments[_i];\r\n        }\r\n        data.forEach(function (dat) {\r\n            fetch(dat.url)\r\n                .then(function (res) { return res.arrayBuffer(); })\r\n                .then(function (arrayBuffer) { return ctx.decodeAudioData(arrayBuffer); })\r\n                .then(function (audioBuffer) {\r\n                _this.setData({ id: dat.id, data: audioBuffer.getChannelData(0) }).process();\r\n            })\r\n                .catch(function (e) { return console.log(e); });\r\n        });\r\n        return this;\r\n    };\r\n    DomRenderWaveShaper.prototype.setInteraction = function (element) {\r\n        if (element == null)\r\n            throw Error('Interaction container element could not be found.');\r\n        this.unregister();\r\n        element.setAttribute('touch-action', 'none');\r\n        var hammer = new Hammer(element, hammerconfig_1.default);\r\n        this._hammer = hammer;\r\n        drag_1.default(this, hammer, dragstate_1.dragState);\r\n        cut_1.default(this, hammer);\r\n        pan_1.default(this, hammer);\r\n        zoom_1.default(this, hammer);\r\n        resize_1.default(this, hammer);\r\n        this.unregister = function () {\r\n            hammer.destroy();\r\n        };\r\n        return this;\r\n    };\r\n    DomRenderWaveShaper.prototype.clearInteraction = function () {\r\n        this.unregister();\r\n        this.unregister = function () { };\r\n        this._hammer = null;\r\n    };\r\n    return DomRenderWaveShaper;\r\n}(waveshaper_1.WaveShaper));\r\nexports.default = DomRenderWaveShaper;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Hammer = __webpack_require__(1);\r\nvar hammerOptions = {\r\n    touchAction: 'pan-y',\r\n    recognizers: [\r\n        [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }],\r\n        [Hammer.Pinch, { enable: true }],\r\n        [Hammer.Tap]\r\n    ]\r\n};\r\nexports.default = hammerOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nexports.default = (function (manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'cut' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('tap', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (options == null || !shouldHandle(target, options))\r\n            return;\r\n        // Allready checked for null\r\n        var id = target.getAttribute('data-wave-id');\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = target.getBoundingClientRect();\r\n        var time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        var newSegment = __assign({}, segment, { offsetStart: time - segment.start, id: options.generateId() });\r\n        segment.end = time;\r\n        wave.intervals.push(newSegment);\r\n        manager.flatten(wave.id);\r\n        manager.process(wave.id);\r\n    });\r\n});\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager Waveshape Manager\r\n * @param hammer Hammer instance\r\n * @param container Container element\r\n */\r\nexports.default = (function (manager, hammer, dragState) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'drag' && target.hasAttribute('data-wave-id'); };\r\n    /**\r\n     * Sets up the drag by finding the\r\n     */\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        // Allready checked for existance\r\n        var id = target.getAttribute('data-wave-id');\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = target.getBoundingClientRect();\r\n        var time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        dragState.options = options;\r\n        dragState.activeSegment = segment;\r\n        dragState.activeSegmentStart = dragState.activeSegment.start;\r\n        dragState.duration = segment.end - segment.start;\r\n        dragState.activeSegment.index = 1000;\r\n        dragState.dragWave = wave;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || dragState.activeSegment == null || dragState.dragWave == null\r\n            || dragState.dragging || !shouldHandle(target, dragState.options))\r\n            return;\r\n        dragState.dragging = true;\r\n        /**\r\n         * TODO below implementation stops all updates on touch devices on new track (tested on Samsung Galaxy s8),\r\n         * when dragged back to original keeps working. Works on desktop, it's a small performance improvement as\r\n         * it prevents a single track flatten + process when transferring a segment between tracks.\r\n         */\r\n        //// If the target has moved it is handled by the mouseHover function\r\n        // const id = ev.target.getAttribute('data-wave-id');\r\n        // if(id !== dragState.dragWave.id)\r\n        //     return;\r\n        var change = (ev.deltaX * dragState.options.samplesPerPixel) / dragState.options.samplerate;\r\n        var newTime = dragState.activeSegmentStart + change;\r\n        if (newTime + dragState.activeSegment.offsetStart < 0) {\r\n            newTime = -dragState.activeSegment.offsetStart;\r\n        }\r\n        dragState.activeSegment.start = newTime;\r\n        dragState.activeSegment.end = newTime + dragState.duration;\r\n        manager.flatten(dragState.dragWave.id);\r\n        manager.process(dragState.dragWave.id);\r\n        dragState.dragging = false;\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n        dragState.activeSegment = null;\r\n        dragState.activeSegmentStart = 0;\r\n        dragState.dragWave = null;\r\n        dragState.options = null;\r\n        dragState.duration = 0;\r\n    });\r\n});\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar endMargin = 500;\r\nvar panState = {\r\n    panStart: 0,\r\n    panMax: 0,\r\n    options: null\r\n};\r\n/**\r\n * Adds pan functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'pan' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        panState.panMax = manager.scrollWidth + endMargin;\r\n        panState.panStart = options.scrollPosition;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        panState.options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, panState.options))\r\n            return;\r\n        var position = panState.panStart - ev.deltaX;\r\n        var newPosition = position > 0 ? position : 0;\r\n        // If it was and is still 0 no need to update\r\n        if (newPosition === panState.options.scrollPosition)\r\n            return;\r\n        if (newPosition > panState.panMax - panState.options.width)\r\n            return;\r\n        manager.setOptions({ scrollPosition: newPosition }).process();\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (panState.options == null || !shouldHandle(target, panState.options))\r\n            return;\r\n        panState.options = null;\r\n        panState.panStart = 0;\r\n        panState.panMax = 0;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar endMargin = 500;\r\nvar zoomState = {\r\n    maxWidth: 0,\r\n    sppStart: 0,\r\n    options: null\r\n};\r\n/**\r\n * Adds pinch zoom functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'pan' && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('pinchstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        zoomState.sppStart = options.samplesPerPixel;\r\n        zoomState.maxWidth = manager.scrollWidth + endMargin;\r\n    });\r\n    hammer.on('pinchmove', function (ev) {\r\n        zoomState.options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n        var sampleAtLeft = zoomState.options.scrollPosition * zoomState.options.samplesPerPixel;\r\n        var samplesInView = zoomState.options.width * zoomState.options.samplesPerPixel;\r\n        var samplesToCenter = samplesInView / 2;\r\n        var newSpp = zoomState.sppStart * ev.scale;\r\n        var newSamplesInView = zoomState.options.width * newSpp;\r\n        var newSamplesToCenter = newSamplesInView / 2;\r\n        var maxWidth = manager.scrollWidth + endMargin;\r\n        var maxSamplesInView = maxWidth * zoomState.options.samplerate;\r\n        if (newSamplesInView >= maxSamplesInView)\r\n            return;\r\n        var newScroll = (sampleAtLeft + samplesToCenter - newSamplesToCenter) / newSpp;\r\n        manager.setOptions({\r\n            samplesPerPixel: newSpp,\r\n            scrollPosition: newScroll >= 0 ? newScroll : 0\r\n        }).process();\r\n    });\r\n    hammer.on('pinchend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n        zoomState.sppStart = 0;\r\n        zoomState.maxWidth = 0;\r\n        zoomState.options = null;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar resizeState = {\r\n    activeSegment: null,\r\n    activeSegmentSide: null,\r\n    activeSegmentOffsetStart: 0,\r\n    activeSegmentOffsetEnd: 0,\r\n    dragWave: null,\r\n    options: null\r\n};\r\n/**\r\n * Adds drag functionality to waveshaper\r\n *\r\n * @param manager\r\n * @param hammer\r\n */\r\nfunction default_1(manager, hammer) {\r\n    var shouldHandle = function (target, options) { return options.mode === 'resize' && target != null && target.hasAttribute('data-wave-id'); };\r\n    hammer.on('panstart', function (ev) {\r\n        var options = manager.options;\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n        // Already checked that it exists\r\n        var id = target.getAttribute('data-wave-id');\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        var bb = target.getBoundingClientRect();\r\n        var time = ((options.scrollPosition + (ev.center.x - bb.left)) * options.samplesPerPixel) / options.samplerate;\r\n        var interval = wave.flattened.find(function (i) { return i.start + i.offsetStart <= time && i.end >= time; });\r\n        if (interval == null)\r\n            return;\r\n        resizeState.activeSegmentSide =\r\n            time < interval.start + interval.offsetStart + ((interval.end - (interval.start + interval.offsetStart)) / 2) ?\r\n                'left' :\r\n                'right';\r\n        var segment = wave.intervals.find(function (s) { return s.id === interval.id; });\r\n        if (segment == null)\r\n            return;\r\n        resizeState.options = options;\r\n        resizeState.activeSegment = segment;\r\n        resizeState.activeSegmentOffsetStart = segment.offsetStart;\r\n        resizeState.activeSegmentOffsetEnd = segment.end;\r\n        segment.index = 1000;\r\n        resizeState.dragWave = wave;\r\n    });\r\n    hammer.on('panmove', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (resizeState.dragWave == null || resizeState.activeSegment == null || resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n        var options = manager.options;\r\n        var change = (ev.deltaX * options.samplesPerPixel) / options.samplerate;\r\n        var newTime = resizeState.activeSegmentSide === 'left' ?\r\n            resizeState.activeSegmentOffsetStart + change :\r\n            resizeState.activeSegmentOffsetEnd + change;\r\n        // Don't allow offset to become less than 0\r\n        if (newTime < 0) {\r\n            newTime = 0;\r\n        }\r\n        var active = resizeState.activeSegment;\r\n        var newDuration = resizeState.activeSegmentSide === 'left' ?\r\n            active.end - active.start - newTime :\r\n            newTime - active.start - active.offsetStart;\r\n        // Do not allow resizing \r\n        if (newDuration <= 2) {\r\n            return;\r\n        }\r\n        resizeState.activeSegmentSide === 'left' ?\r\n            active.offsetStart = newTime :\r\n            active.end = newTime;\r\n        manager.flatten(resizeState.dragWave.id);\r\n        manager.process(resizeState.dragWave.id);\r\n    });\r\n    hammer.on('panend', function (ev) {\r\n        var target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n        resizeState.activeSegment = null;\r\n        resizeState.activeSegmentOffsetStart = 0;\r\n        resizeState.activeSegmentOffsetEnd = 0;\r\n        resizeState.activeSegmentSide = null;\r\n        resizeState.dragWave = null;\r\n        resizeState.options = null;\r\n    });\r\n}\r\nexports.default = default_1;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n *\r\n *\r\n * @export\r\n * @param waveform Sampled data for each pixel, max at 0, min at 1\r\n * @param options\r\n * @param ctx\r\n * @param color\r\n */\r\nexports.default = (function (waveform, options, ctx, color) {\r\n    var scale = options.height / 2;\r\n    var width = options.width;\r\n    ctx.fillStyle = color;\r\n    ctx.clearRect(0, 0, width, options.height);\r\n    for (var i = 0, inSegment = false, segmentStart = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        var pointInSegment = waveform[index + 3] === 1;\r\n        if (!inSegment && pointInSegment) {\r\n            inSegment = true;\r\n            segmentStart = i;\r\n        }\r\n        else if (inSegment && (!pointInSegment || i === width - 1)) {\r\n            inSegment = false;\r\n            ctx.fillRect(segmentStart, 0, i - segmentStart, options.height);\r\n        }\r\n    }\r\n    ctx.fillStyle = 'black';\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, scale);\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        ctx.lineTo(i, Math.round((waveform[index] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.moveTo(0, scale);\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        ctx.lineTo(i, Math.round((waveform[index + 1] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.closePath();\r\n    for (var i = 0; i < width; i++) {\r\n        var index = i * 4;\r\n        if (waveform[index - 4 + 2] === 0 && waveform[index + 2] === 1) {\r\n            ctx.rect(i, 0, 1, options.height);\r\n        }\r\n    }\r\n    ctx.fill();\r\n});\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = (function (manager, canvas, dragState) {\r\n    var enterlistener = function (ev) { return pointerEnter(ev); };\r\n    var downlistener = function (ev) { return canvas.releasePointerCapture(ev.pointerId); };\r\n    /**\r\n     * Fires when the mouse moves over the container,\r\n     * If a segment is being dragged and the pointer moves\r\n     * into another canvas the segment is tranfered to the\r\n     * new canvas.\r\n     */\r\n    canvas.addEventListener('pointerenter', enterlistener);\r\n    canvas.addEventListener('pointerdown', downlistener);\r\n    var destroy = function () {\r\n        canvas.removeEventListener('pointerenter', enterlistener);\r\n        canvas.removeEventListener('pointerdown', downlistener);\r\n    };\r\n    var pointerEnter = function (ev) {\r\n        if (dragState.options == null || dragState.options.mode !== 'drag' || dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n        var canvas = dragState.options.getEventTarget(ev);\r\n        if (canvas == null || !(canvas instanceof HTMLCanvasElement))\r\n            return;\r\n        var id = canvas.getAttribute('data-wave-id');\r\n        if (id == null)\r\n            return;\r\n        var wave = manager.getTrack(id);\r\n        if (wave == null)\r\n            return;\r\n        if (dragState.dragWave.id !== id) {\r\n            var index = dragState.dragWave.intervals.indexOf(dragState.activeSegment);\r\n            dragState.dragWave.intervals.splice(index, 1);\r\n            wave.intervals.push(dragState.activeSegment);\r\n            dragState.activeSegment.index = 1000;\r\n            var currentId = dragState.dragWave.id;\r\n            dragState.dragWave = wave;\r\n            manager.flatten(wave.id, currentId);\r\n            manager.process(wave.id, currentId);\r\n        }\r\n    };\r\n    return destroy;\r\n});\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(0);\r\nvar defaultDomOptions = __assign({}, waveshaper_1.defaultConfig, { mode: 'pan', height: 150, getEventTarget: function (ev) { return ev.target; }, generateId: function () { return Math.random().toString(); }, registerSetsActive: true });\r\nexports.default = defaultDomOptions;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.dragState = {\r\n    activeSegment: null,\r\n    activeSegmentStart: 0,\r\n    dragWave: null,\r\n    options: null,\r\n    duration: 0,\r\n    dragging: false\r\n};\r\n\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// waveshaper-dom.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2ab2eb7b1450a0f7daa1","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waveshaper\"] = factory();\n\telse\n\t\troot[\"waveshaper\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar peak_1 = __webpack_require__(1);\r\nvar rms_1 = __webpack_require__(2);\r\nvar flatten_1 = __webpack_require__(3);\r\nvar Track = /** @class */ (function () {\r\n    function Track(id, intervals) {\r\n        this.id = id;\r\n        this.intervals = intervals || [];\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    }\r\n    Object.defineProperty(Track.prototype, \"flattened\", {\r\n        get: function () { return this._flattened.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Track.prototype.flatten = function () {\r\n        this._flattened = flatten_1.default(this.intervals);\r\n    };\r\n    /**\r\n     * Gets the duration of the audio in seconds\r\n     *\r\n     * @returns Decimal value of total duration in seconds\r\n     */\r\n    Track.prototype.getDuration = function () {\r\n        return Math.max.apply(Math, this.intervals.map(function (s) { return s.end; }));\r\n    };\r\n    /**\r\n     * Gets the summerized values for the current settings\r\n     *\r\n     * @param options\r\n     * @param dataMap\r\n     * @returns Two dimensional array, one entry for each pixel, for each pixel a min\r\n     * and a max value.\r\n     */\r\n    Track.prototype.calculate = function (options, dataMap) {\r\n        switch (options.meterType) {\r\n            case 'peak':\r\n                return peak_1.default(options, this.flattened, dataMap);\r\n            default:\r\n                return rms_1.default(options, this.flattened, dataMap);\r\n        }\r\n    };\r\n    return Track;\r\n}());\r\nexports.default = Track;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculates peak values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var min = 0, max = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize) {\r\n            var sample = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (sample > max)\r\n                max = sample;\r\n            else if (sample < min)\r\n                min = sample;\r\n        }\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Calculate rms values\r\n *\r\n * @export\r\n * @param resolution\r\n * @param samplesPerPixel\r\n * @param width\r\n * @param intervals\r\n * @param scrollPosition\r\n * @param sampleRate\r\n * @param dataMap\r\n * @returns\r\n */\r\nexports.default = (function (options, intervals, dataMap) {\r\n    var sampleSize = Math.ceil(options.samplesPerPixel / options.resolution);\r\n    var start = options.scrollPosition * options.samplesPerPixel;\r\n    var startSecond = start / options.samplerate;\r\n    var secondsPerPixel = options.samplesPerPixel / options.samplerate;\r\n    var endSecond = startSecond + (options.width * secondsPerPixel);\r\n    var peaks = new Float32Array(options.width * 4);\r\n    var currentIntervalIndex = intervals.findIndex(function (i) { return i.end > startSecond && i.start + i.offsetStart < endSecond; });\r\n    // There are no intervals in this range so return empty array\r\n    if (currentIntervalIndex === -1)\r\n        return peaks;\r\n    var maxIntervalIncrementIndex = intervals.length - 1;\r\n    var currentInterval = intervals[currentIntervalIndex];\r\n    var buffer = dataMap.get(currentInterval.source);\r\n    // For each pixel we display\r\n    for (var i = 0; i < options.width; i++) {\r\n        var currentSecond = startSecond + (i * secondsPerPixel);\r\n        if (currentSecond >= currentInterval.end) {\r\n            if (currentIntervalIndex === maxIntervalIncrementIndex) {\r\n                return peaks;\r\n            }\r\n            else {\r\n                currentInterval = intervals[++currentIntervalIndex];\r\n                buffer = dataMap.get(currentInterval.source);\r\n            }\r\n        }\r\n        if (currentInterval.start + currentInterval.offsetStart > currentSecond) {\r\n            continue;\r\n        }\r\n        var startBorder = currentSecond - secondsPerPixel < currentInterval.start + currentInterval.offsetStart;\r\n        var endBorder = currentSecond + secondsPerPixel > currentInterval.end;\r\n        var intervalBorder = startBorder || endBorder ? 1 : 0;\r\n        if (buffer == null) {\r\n            peaks.set([0, 0, intervalBorder, 1], (i * 4));\r\n            continue;\r\n        }\r\n        var secondsIntoInterval = currentSecond - currentInterval.start;\r\n        var startSample = Math.floor(secondsIntoInterval * options.samplerate);\r\n        var endSample = startSample + options.samplesPerPixel;\r\n        var length_1 = buffer.length;\r\n        var loopEnd = length_1 < endSample ? length_1 : endSample;\r\n        // Cycle through the data-points relevant to the pixel\r\n        // Don't cycle through more than sampleSize frames per pixel.\r\n        var posSum = 0, negSum = 0, count = 0;\r\n        for (var j = startSample; j < loopEnd; j += sampleSize, count++) {\r\n            var val = buffer[j];\r\n            // Keep track of positive and negative values separately\r\n            if (val > 0) {\r\n                posSum += val * val;\r\n            }\r\n            else {\r\n                negSum += val * val;\r\n            }\r\n        }\r\n        var min = -Math.sqrt(negSum / count);\r\n        var max = Math.sqrt(posSum / count);\r\n        peaks.set([min, max, intervalBorder, 1], (i * 4));\r\n    }\r\n    return peaks;\r\n});\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar start = function (segment) { return segment.start + segment.offsetStart; };\r\n/**\r\n * The algorithm first calculates real start and end times of each segment,\r\n * sorts them by priority, then start time.\r\n *\r\n * Finally it merges the segments by index so there are no overlapping\r\n * segments and those with highest index are on top.\r\n *\r\n * @export\r\n * @param segments Segments to flatten\r\n * @returns flattened Interval array\r\n */\r\nexports.default = (function (segments) {\r\n    if (segments == null || segments.length === 0)\r\n        return [];\r\n    var sorted = sort(segments);\r\n    var normalized = normalizeIndex(sorted);\r\n    var copied = copy(normalized);\r\n    var grouped = groupByIndex(copied);\r\n    return weightedMerge(grouped);\r\n});\r\n/**\r\n * Copies elements so original are unaltered\r\n *\r\n * @param intervals\r\n */\r\nvar copy = function (intervals) { return intervals.map(function (i) { return (__assign({}, i)); }); };\r\n/**\r\n * When an element is altered the index is set very high,\r\n * this functions normalizes to indexes back to 0\r\n *\r\n * @param segments\r\n */\r\nvar normalizeIndex = function (segments) {\r\n    var index = 0;\r\n    var preNormalizeIndex = Number.MIN_SAFE_INTEGER;\r\n    segments.forEach(function (el) {\r\n        if (el.index > preNormalizeIndex) {\r\n            preNormalizeIndex = el.index;\r\n            el.index = ++index;\r\n        }\r\n        else {\r\n            el.index = index;\r\n        }\r\n    });\r\n    return segments;\r\n};\r\n/**\r\n * Sorts the intervals by index, then by start\r\n *\r\n * @param intervals\r\n * @return Interval array\r\n */\r\nvar sort = function (intervals) {\r\n    return intervals.sort(function (a, b) { return cmp(a.index, b.index) || cmp(start(a), start(b)); });\r\n};\r\n/**\r\n * Returns a map of intervals grouped by the key property\r\n *\r\n * @param intervals\r\n * @param key\r\n *\r\n * @returns Map of index => interval[]\r\n */\r\nvar groupByIndex = function (intervals) {\r\n    return intervals.reduce(function (groups, interval) {\r\n        (groups[interval.index] = groups[interval.index] || []).push(interval);\r\n        return groups;\r\n    }, {});\r\n};\r\n/**\r\n * Merges all the groups by index\r\n *\r\n * @param grouped\r\n * @returns Interval array\r\n */\r\nvar weightedMerge = function (grouped) {\r\n    var flattened = null;\r\n    for (var _i = 0, _a = Object.keys(grouped); _i < _a.length; _i++) {\r\n        var index = _a[_i];\r\n        var merged = merge(grouped[index]);\r\n        if (flattened == null) {\r\n            flattened = merged;\r\n        }\r\n        else {\r\n            flattened = combine(merged, flattened);\r\n        }\r\n    }\r\n    return flattened;\r\n};\r\n/**\r\n * Merges a set of intervals with the same index and remove any overlaps, left to right\r\n *\r\n * @param intervals\r\n * @returns Interval array\r\n */\r\nvar merge = function (intervals) {\r\n    if (intervals.length <= 1)\r\n        return intervals;\r\n    var result = [];\r\n    var current = intervals[0];\r\n    for (var i = 1; i < intervals.length; i++) {\r\n        var next = intervals[i];\r\n        // If current is completely overlapped by second it is merged into it\r\n        if (current.end >= next.end) {\r\n            continue;\r\n            // Resolves partial overlaps by setting end of current to start of next\r\n        }\r\n        else if (start(next) < current.end) {\r\n            result.push(__assign({}, current, { end: start(next) }));\r\n            current = next;\r\n        }\r\n        else {\r\n            // No overlap, push onto results\r\n            result.push(current);\r\n            current = next;\r\n        }\r\n    }\r\n    result.push(current);\r\n    return result;\r\n};\r\n/**\r\n * Given two sets of intervals it merges them so the highIndexes set has priority\r\n *\r\n * @param highIndexes\r\n * @param lowIndexes\r\n *\r\n * @returns Interval array\r\n */\r\nvar combine = function (highIndexes, lowIndexes) {\r\n    var highIndex = 0;\r\n    var lowIndex = 0;\r\n    var merged = [];\r\n    while (highIndex < highIndexes.length || lowIndex < lowIndexes.length) {\r\n        var high = highIndexes[highIndex];\r\n        var low = lowIndexes[lowIndex];\r\n        // Only low priority left so push low onto results\r\n        if (highIndex === highIndexes.length) {\r\n            merged.push(__assign({}, low));\r\n            lowIndex++;\r\n            // Only high priority left so push high onto results\r\n        }\r\n        else if (lowIndex === lowIndexes.length) {\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // High priority start before or at same time as low\r\n        }\r\n        else if (start(high) <= start(low)) {\r\n            // No overlap between low and high\r\n            // low:                 ----------------------\r\n            // high: ---------------\r\n            if (high.end <= start(low)) {\r\n                // Partial overlap where high ends after low\r\n                // low:                 ----------------------\r\n                // high: ----------------------\r\n            }\r\n            else if (high.end < low.end) {\r\n                low.offsetStart = high.end - low.start;\r\n                // Low index completely overlapped, dismiss it\r\n                // low:               -----------\r\n                // high: -------------------------------------\r\n            }\r\n            else {\r\n                lowIndex++;\r\n            }\r\n            merged.push(__assign({}, high));\r\n            highIndex++;\r\n            // Low priority starts before high\r\n        }\r\n        else {\r\n            // No overlap between low and high intervals\r\n            // low: ---------------\r\n            // high                ----------------------\r\n            if (low.end <= start(high)) {\r\n                merged.push(__assign({}, low));\r\n                lowIndex++;\r\n                // Partial overlap where high ends after low\r\n                // low: ---------------------\r\n                // high                ----------------------\r\n            }\r\n            else if (high.end > low.end) {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                lowIndex++;\r\n                // Partial overlap where high ends before low\r\n                // low: -------------------------------------\r\n                // high             -----------\r\n            }\r\n            else {\r\n                merged.push(__assign({}, low, { end: start(high) }));\r\n                low.offsetStart = high.end - low.start;\r\n            }\r\n        }\r\n    }\r\n    return merged;\r\n};\r\n/**\r\n *\r\n * @param a\r\n * @param b\r\n */\r\nvar cmp = function (a, b) {\r\n    if (a > b)\r\n        return +1;\r\n    if (a < b)\r\n        return -1;\r\n    return 0;\r\n};\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar defaultOptions = {\r\n    scrollPosition: 0,\r\n    samplesPerPixel: 1024,\r\n    resolution: 10,\r\n    meterType: 'rms',\r\n    width: 300,\r\n    samplerate: 44100\r\n};\r\nexports.default = defaultOptions;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar waveshaper_1 = __webpack_require__(6);\r\nexports.WaveShaper = waveshaper_1.default;\r\nvar track_1 = __webpack_require__(0);\r\nexports.Track = track_1.default;\r\nvar managerconfig_1 = __webpack_require__(4);\r\nexports.defaultConfig = managerconfig_1.default;\r\nvar rms_1 = __webpack_require__(2);\r\nexports.rms = rms_1.default;\r\nvar peak_1 = __webpack_require__(1);\r\nexports.peak = peak_1.default;\r\nvar flatten_1 = __webpack_require__(3);\r\nexports.flatten = flatten_1.default;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar track_1 = __webpack_require__(0);\r\nvar managerconfig_1 = __webpack_require__(4);\r\n/**\r\n *\r\n *\r\n * @export\r\n */\r\nvar WaveShaper = /** @class */ (function () {\r\n    /**\r\n     * @param [options=defaultOptions] Initial options\r\n     * @throws Throws an error if samplerate is null or NaN\r\n     */\r\n    function WaveShaper(options) {\r\n        if (options === void 0) { options = managerconfig_1.default; }\r\n        /**\r\n         * Map of waveshapers managed by the manager\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.tracks = new Map();\r\n        /**\r\n         * Map of audio data\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.audioData = new Map();\r\n        /**\r\n         * @description Map of callback functions\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        this.callbackMap = new Map();\r\n        this._activeWaveShapers = [];\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, managerconfig_1.default, options);\r\n    }\r\n    Object.defineProperty(WaveShaper.prototype, \"options\", {\r\n        /**\r\n         * @description Currect settings\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return __assign({}, this._options); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"activeWaveShapers\", {\r\n        /**\r\n         * @description Active id's, redraws when draw is called without argument\r\n         *\r\n         * @readonly\r\n         * @unused\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._activeWaveShapers.slice(); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"lastProcessResult\", {\r\n        /**\r\n         * @description Last result of calling process, argument given to all callbacks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._lastProcessResult; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(WaveShaper.prototype, \"duration\", {\r\n        /**\r\n         * @description Total duration of all tracks\r\n         *\r\n         * @readonly\r\n         * @memberof WaveShaper\r\n         */\r\n        get: function () { return this._duration; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gives the position corresponding to a given time\r\n     *\r\n     * @param time\r\n     */\r\n    WaveShaper.prototype.timeToPosition = function (time) {\r\n        return (time * this._options.samplerate) / this._options.samplesPerPixel;\r\n    };\r\n    /**\r\n     * Gives the time corresponding to a given position\r\n     * @param position\r\n     */\r\n    WaveShaper.prototype.positionToTime = function (position) {\r\n        return (position * this._options.samplesPerPixel) / this._options.samplerate;\r\n    };\r\n    /**\r\n     * @description Flattens the segments of the given waveshaper id\r\n     *\r\n     * @param id\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.flatten = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this.getProcessIds.apply(this, ids).forEach(function (id) {\r\n            var waveShaper = _this.getTrack(id);\r\n            if (waveShaper != null)\r\n                waveShaper.flatten();\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Processes all relevant WaveShapers and invokes registered callbacks\r\n     *\r\n     * @param ids Options array of id's to draw\r\n     * @param forceDraw Force redraw of the given waves\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.process = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        var toProcess = this.getProcessIds.apply(this, ids);\r\n        var options = __assign({}, this.options);\r\n        var data = [];\r\n        for (var i = 0; i < toProcess.length; i++) {\r\n            var id = toProcess[i];\r\n            var wave = this.getTrack(id);\r\n            if (wave == null)\r\n                continue;\r\n            var peaks = wave.calculate(options, this.audioData);\r\n            data.push({ id: id, data: peaks });\r\n        }\r\n        // Invoke callbacks after returning value.\r\n        this._lastProcessResult = { options: options, data: data };\r\n        this.invokeCallbacks(this._lastProcessResult);\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers a callback that fires when the track with given id is processed\r\n     *\r\n     * @param id id of Track to register to\r\n     * @param callBack will be invoked when the given track is processed\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.on = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null) {\r\n            this.callbackMap.set(id, [callBack]);\r\n        }\r\n        else {\r\n            callbackArray.push(callBack);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Unregisters a callback from the given track, will no longer be called\r\n     *\r\n     * @param id id of Track to unregister from\r\n     * @param callBack callback to remove\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.off = function (id, callBack) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return this;\r\n        var index = callbackArray.indexOf(callBack);\r\n        if (index < 0)\r\n            return this;\r\n        callbackArray = callbackArray.splice(index, 1);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Merges the given options into the current and returns updated options\r\n     *\r\n     * @param options A (partial) ManagerOptions object\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setOptions = function (options) {\r\n        if (!this.optionsValid(options)) {\r\n            throw new Error(\"Invalid options given: \" + JSON.stringify(options));\r\n        }\r\n        this._options = __assign({}, this.options, options);\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds a waveshaper to the manager\r\n     *\r\n     * @param id id of WaveShaper\r\n     * @param segments Segments in wave\r\n     * @param color Background color of segments\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setTracks = function () {\r\n        var tracks = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            tracks[_i] = arguments[_i];\r\n        }\r\n        for (var i = 0; i < tracks.length; i++) {\r\n            var track = tracks[i];\r\n            var foundWave = this.getTrack(track.id);\r\n            if (foundWave == null) {\r\n                var wave = new track_1.default(track.id, track.intervals);\r\n                this.tracks.set(track.id, wave);\r\n            }\r\n            else {\r\n                foundWave.intervals = track.intervals || [];\r\n                foundWave.flatten();\r\n            }\r\n        }\r\n        this._duration = this.getDuration();\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Adds audio data to the waveshaper and redraws waveshapers using it\r\n     *\r\n     * @param id  Data id, refered to by source parameter of segments\r\n     * @param data AudioBuffer with audio data\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setData = function () {\r\n        var _this = this;\r\n        var data = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            data[_i] = arguments[_i];\r\n        }\r\n        data.forEach(function (d) {\r\n            _this.audioData.set(d.id, d.data);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description The given id's are set as the active waveshapers, process only processes these when set,\r\n     * call with no values to allways process all values (default)\r\n     *\r\n     * @param ids Waveshaper id's to set as active\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.setActive = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        this._activeWaveShapers = ids;\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Removes the waves and all callbacks with given id from the manager\r\n     *\r\n     * @param id\r\n     *\r\n     * @returns WaveShaper instance\r\n     */\r\n    WaveShaper.prototype.clearTracks = function () {\r\n        var _this = this;\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        ids.forEach(function (id) {\r\n            _this.removeCallbacksById(id);\r\n            _this.tracks.delete(id);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * @description Gets Track with given id\r\n     *\r\n     * @param id\r\n     * @returns Track with given ID\r\n     */\r\n    WaveShaper.prototype.getTrack = function (id) {\r\n        return this.tracks.get(id);\r\n    };\r\n    /**\r\n     * Validates given options\r\n     *\r\n     * @param options\r\n     * @returns true if valid, false if not\r\n     */\r\n    WaveShaper.prototype.optionsValid = function (options) {\r\n        return (options.samplesPerPixel === undefined || options.samplesPerPixel > 0) &&\r\n            (options.meterType === undefined || options.meterType) &&\r\n            (options.resolution === undefined || options.resolution > 0) &&\r\n            (options.width === undefined || options.width > 0) &&\r\n            (options.scrollPosition === undefined || options.scrollPosition >= 0) &&\r\n            (options.samplerate === undefined || options.samplerate > 0);\r\n    };\r\n    /**\r\n     * Invokes all registered callbacks registered to a waveshaper id in the data list\r\n     *\r\n     * @param options\r\n     * @param data\r\n     */\r\n    WaveShaper.prototype.invokeCallbacks = function (result) {\r\n        for (var i = 0; i < result.data.length; i++) {\r\n            var trackResult = result.data[i];\r\n            var callbacks = this.callbackMap.get(trackResult.id);\r\n            if (callbacks == null)\r\n                continue;\r\n            for (var j = 0; j < callbacks.length; j++) {\r\n                var callback = callbacks[j];\r\n                callback(result.options, new Float32Array(trackResult.data));\r\n            }\r\n        }\r\n    };\r\n    WaveShaper.prototype.getProcessIds = function () {\r\n        var ids = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            ids[_i] = arguments[_i];\r\n        }\r\n        if (ids.length > 0)\r\n            return ids;\r\n        if (this._activeWaveShapers.length > 0)\r\n            return this._activeWaveShapers;\r\n        return Array.from(this.tracks.keys());\r\n    };\r\n    WaveShaper.prototype.removeCallbacksById = function (id) {\r\n        var callbackArray = this.callbackMap.get(id);\r\n        if (callbackArray == null)\r\n            return;\r\n        callbackArray.splice(0, callbackArray.length);\r\n        this.callbackMap.delete(id);\r\n    };\r\n    /**\r\n     * @description Returns the maximum duration of all the waveshapers managed by this class\r\n     *\r\n     * @returns Maximum duration in seconds\r\n     * @memberof WaveShaper\r\n     */\r\n    WaveShaper.prototype.getDuration = function () {\r\n        return Array.from(this.tracks.values()).reduce(function (maxDuration, waveShaper) {\r\n            var duration = waveShaper.getDuration();\r\n            return duration > maxDuration ? duration : maxDuration;\r\n        }, 0);\r\n    };\r\n    return WaveShaper;\r\n}());\r\nexports.default = WaveShaper;\r\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=waveshaper.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/waveshaper/dist/waveshaper.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Hammer\",\"commonjs2\":\"hammerjs\",\"commonjs\":\"hammerjs\",\"amd\":\"hammerjs\",\"umd\":\"hammerjs\"}\n// module id = 1\n// module chunks = 0","import DomRenderWaveShaper from './core/domrender-waveshaper';\r\n\r\nexport {\r\n    DomRenderWaveShaper\r\n}\r\n\r\nexport default new DomRenderWaveShaper();\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import { WaveShaper } from \"waveshaper\";\r\nimport * as Hammer from \"hammerjs\";\r\n\r\nimport hammerConfig from '../config/hammerconfig';\r\nimport cut from '../interactions/cut';\r\nimport drag from '../interactions/drag';\r\nimport pan from '../interactions/pan';\r\nimport zoom from '../interactions/zoom';\r\nimport resize from '../interactions/resize';\r\nimport line from '../render/line';\r\nimport enter from '../interactions/enter';\r\nimport defaultDomOptions, { DomInput, DomOptions } from \"../config/dom-config\";\r\nimport { dragState } from \"../models/dragstate\";\r\n\r\n/**\r\n * Extends WaveShapeManager to allow for easy canvas rendering registration.\r\n * \r\n * @inheritDoc\r\n */\r\nexport default class DomRenderWaveShaper extends WaveShaper {\r\n    private unregister = () => {};\r\n\r\n    private unregisterMap = new Map<string, () => void>();\r\n    private canvasMap = new Map<string, () => void>();\r\n\r\n    public get scrollWidth(): number { return (this._duration * this._options.samplerate) / this._options.samplesPerPixel }\r\n\r\n    public get options(): DomOptions { return { ...this._options }; }\r\n    protected _options: DomOptions;\r\n\r\n    public get hammer(): HammerManager | null { return this._hammer; }\r\n    protected _hammer: HammerManager | null;\r\n\r\n    constructor(options: DomInput = defaultDomOptions) {\r\n        super(options);\r\n\r\n        this._options = { ...defaultDomOptions, ...this._options };\r\n    }\r\n\r\n    setOptions(input: DomInput) {\r\n        this._options = { ...this._options, ...input };\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @description When a canvas is registered through this method each time the \r\n     * waveform is updated the canvas will be rerendered.\r\n     * \r\n     * It returns an unregister method, call to stop receiving callbacks.\r\n     * \r\n     * @param id WaveShaper id to register to.\r\n     * @param canvas Canvas to render to\r\n     * @param color Background color of segments\r\n     */\r\n    registerCanvas(id: string, canvas: HTMLCanvasElement, color: string): DomRenderWaveShaper {\r\n        const ctx = canvas.getContext('2d');\r\n        if(ctx == null) throw Error('Cannot get context from canvas.');\r\n\r\n        // Add classes and data attributes\r\n        canvas.classList.add('waveshaper');\r\n        canvas.setAttribute('data-wave-id', id);\r\n\r\n        canvas.style.width = this.options.width + 'px';\r\n        canvas.style.height = this.options.height + 'px';\r\n\r\n        const scale = (devicePixelRatio || 1) < 1 ? 1 : (devicePixelRatio || 1);\r\n\r\n        canvas.width = this.options.width * scale;\r\n        canvas.height = this.options.height;\r\n        \r\n        ctx.scale(scale, 1)\r\n\r\n        const callBack = (options: DomOptions, data: Float32Array) => line(data, options, ctx, color)\r\n        this.on(id, callBack);\r\n\r\n        this.unregisterCanvas(id);\r\n\r\n        \r\n        this.canvasMap.set(id, () => this.off(id, callBack));\r\n\r\n        const unregister = enter(this, canvas, dragState);\r\n        this.unregisterMap.set(id, unregister);\r\n\r\n        // If registerSetsActive is true \r\n        if(this._options.registerSetsActive) {\r\n            this.setActive(...this.activeWaveShapers.concat(id));\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clears the callbacks associated with this canvas\r\n     * \r\n     * @param id \r\n     * @returns Instance of WaveShaper\r\n     */\r\n    unregisterCanvas(id: string): DomRenderWaveShaper {\r\n        const unregister = this.canvasMap.get(id);\r\n        if(unregister != null) {\r\n            unregister();\r\n            this.canvasMap.delete(id);\r\n        }\r\n\r\n        const unregisterEvents = this.unregisterMap.get(id);\r\n        if(unregisterEvents != null) {\r\n            unregisterEvents();\r\n            this.unregisterMap.delete(id);\r\n        }\r\n\r\n        if(this._options.registerSetsActive) {\r\n            const index = this.activeWaveShapers.indexOf(id);\r\n            if(index != -1) this.setActive(...this.activeWaveShapers.splice(index, 1));\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Loads and saves a set of url's to audio files.\r\n     * \r\n     * @param ctx \r\n     * @param data \r\n     */\r\n    loadData(ctx: AudioContext, ...data: { id: string, url: string }[]): DomRenderWaveShaper {\r\n        data.forEach(dat => {\r\n            fetch(dat.url)\r\n            .then(res => res.arrayBuffer())\r\n            .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))\r\n            .then(audioBuffer => {\r\n                this.setData({ id: dat.id, data: audioBuffer.getChannelData(0) }).process();\r\n            })\r\n            .catch(e => console.log(e));\r\n        });\r\n        \r\n        return this;\r\n    }\r\n\r\n    setInteraction(element: HTMLElement) {\r\n        if(element == null) throw Error('Interaction container element could not be found.');\r\n        this.unregister();\r\n\r\n        element.setAttribute('touch-action', 'none');\r\n        \r\n        const hammer = new Hammer(element, hammerConfig);\r\n        this._hammer = hammer;\r\n    \r\n        drag(this, hammer, dragState);\r\n        cut(this, hammer);\r\n        pan(this, hammer);\r\n        zoom(this, hammer);\r\n        resize(this, hammer);\r\n    \r\n        this.unregister = () => {\r\n            hammer.destroy();\r\n        };\r\n\r\n        return this;\r\n    }\r\n\r\n    clearInteraction() {\r\n        this.unregister();\r\n        this.unregister = () => { };\r\n\r\n        this._hammer = null;\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/core/domrender-waveshaper.ts","import * as Hammer from 'hammerjs';\r\n\r\nconst hammerOptions: HammerOptions = {\r\n    touchAction : 'pan-y',\r\n    recognizers: [\r\n        [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }],\r\n        [Hammer.Pinch, { enable : true }],\r\n        [Hammer.Tap]\r\n    ]\r\n}\r\n\r\nexport default hammerOptions;\n\n\n// WEBPACK FOOTER //\n// ./src/config/hammerconfig.ts","import { Interval } from 'waveshaper';\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager) => {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'cut' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('tap', (ev: HammerInput) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(options == null || !shouldHandle(target, options))\r\n            return;\r\n\r\n        // Allready checked for null\r\n        const id = <string>target.getAttribute('data-wave-id');\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n        if(interval == null) return;\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        const newSegment: Interval = { \r\n            ...segment, \r\n            offsetStart: time - segment.start,\r\n            id: options.generateId() \r\n        };\r\n\r\n        segment.end = time;\r\n        wave.intervals.push(newSegment);\r\n        \r\n        manager.flatten(wave.id);\r\n        manager.process(wave.id);\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/cut.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\nimport { DragState } from '../models/dragstate';\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager Waveshape Manager\r\n * @param hammer Hammer instance\r\n * @param container Container element\r\n */\r\nexport default (manager: DomRenderWaveShaper, hammer: HammerManager, dragState: DragState) => {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'drag' && target.hasAttribute('data-wave-id');\r\n\r\n    /**\r\n     * Sets up the drag by finding the \r\n     */\r\n    hammer.on('panstart', (ev: HammerInput) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (!shouldHandle(target, options))\r\n            return;\r\n\r\n        // Allready checked for existance\r\n        const id = <string>target.getAttribute('data-wave-id');\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = target.getBoundingClientRect();\r\n        const time = (options.scrollPosition + (ev.center.x - bb.left)) * (options.samplesPerPixel / options.samplerate);\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n\r\n        if (interval == null)\r\n            return;\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        dragState.options = options;\r\n\r\n        dragState.activeSegment = segment;\r\n        dragState.activeSegmentStart = dragState.activeSegment.start;\r\n        dragState.duration = segment.end - segment.start;\r\n\r\n        dragState.activeSegment.index = 1000;\r\n        dragState.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('panmove', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || dragState.activeSegment == null || dragState.dragWave == null \r\n            || dragState.dragging || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        dragState.dragging = true;\r\n\r\n        /** \r\n         * TODO below implementation stops all updates on touch devices on new track (tested on Samsung Galaxy s8),\r\n         * when dragged back to original keeps working. Works on desktop, it's a small performance improvement as\r\n         * it prevents a single track flatten + process when transferring a segment between tracks.\r\n         */\r\n\r\n        //// If the target has moved it is handled by the mouseHover function\r\n        // const id = ev.target.getAttribute('data-wave-id');\r\n        // if(id !== dragState.dragWave.id)\r\n        //     return;\r\n\r\n        const change = (ev.deltaX * dragState.options.samplesPerPixel) / dragState.options.samplerate;\r\n        let newTime = dragState.activeSegmentStart + change;\r\n\r\n        if (newTime + dragState.activeSegment.offsetStart < 0) {\r\n            newTime = -dragState.activeSegment.offsetStart;\r\n        }\r\n\r\n        dragState.activeSegment.start = newTime;\r\n        dragState.activeSegment.end = newTime + dragState.duration;\r\n\r\n        manager.flatten(dragState.dragWave.id);\r\n        manager.process(dragState.dragWave.id);\r\n\r\n        dragState.dragging = false;\r\n    });\r\n\r\n    hammer.on('panend', (ev: HammerInput) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if (dragState.options == null || !shouldHandle(target, dragState.options))\r\n            return;\r\n\r\n        dragState.activeSegment = null;\r\n        dragState.activeSegmentStart = 0;\r\n        dragState.dragWave = null;\r\n        dragState.options = null;\r\n        dragState.duration = 0;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/drag.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface PanState {\r\n    panStart: number;\r\n    panMax: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst panState: PanState = {\r\n    panStart: 0,\r\n    panMax: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pan functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        panState.panMax = manager.scrollWidth + endMargin;\r\n        panState.panStart = options.scrollPosition;\r\n    });\r\n\r\n    hammer.on('panmove', (ev) =>  {\r\n        panState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n\r\n        if(!shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        const position = panState.panStart - ev.deltaX;\r\n        const newPosition = position > 0 ? position : 0;\r\n\r\n        // If it was and is still 0 no need to update\r\n        if(newPosition === panState.options.scrollPosition)\r\n            return;\r\n\r\n        if(newPosition > panState.panMax - panState.options.width)\r\n            return;\r\n        \r\n        manager.setOptions({ scrollPosition: newPosition }).process();\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(panState.options == null || !shouldHandle(target, panState.options))\r\n            return;\r\n\r\n        panState.options = null;\r\n        panState.panStart = 0;\r\n        panState.panMax = 0;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/pan.ts","import DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\nconst endMargin = 500;\r\n\r\ninterface ZoomState {\r\n    maxWidth: number;\r\n    sppStart: number;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst zoomState: ZoomState = {\r\n    maxWidth: 0,\r\n    sppStart: 0,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds pinch zoom functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'pan' && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('pinchstart', (ev) => {\r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        zoomState.sppStart = options.samplesPerPixel;\r\n        zoomState.maxWidth = manager.scrollWidth + endMargin;\r\n    });\r\n\r\n    hammer.on('pinchmove', (ev) => {\r\n        zoomState.options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n\r\n        const sampleAtLeft = zoomState.options.scrollPosition * zoomState.options.samplesPerPixel;\r\n        const samplesInView = zoomState.options.width * zoomState.options.samplesPerPixel;\r\n        const samplesToCenter = samplesInView / 2;\r\n\r\n        const newSpp = zoomState.sppStart * ev.scale;\r\n\r\n        const newSamplesInView = zoomState.options.width * newSpp;\r\n        const newSamplesToCenter = newSamplesInView / 2;\r\n\r\n        const maxWidth = manager.scrollWidth + endMargin;\r\n        const maxSamplesInView = maxWidth  * zoomState.options.samplerate;\r\n\r\n        if(newSamplesInView >= maxSamplesInView)\r\n            return;\r\n\r\n        const newScroll = (sampleAtLeft + samplesToCenter - newSamplesToCenter) / newSpp;\r\n\r\n        manager.setOptions({\r\n            samplesPerPixel: newSpp,\r\n            scrollPosition: newScroll >= 0 ? newScroll : 0\r\n        }).process();\r\n    });\r\n\r\n    hammer.on('pinchend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(zoomState.options == null || !shouldHandle(target, zoomState.options))\r\n            return;\r\n\r\n        zoomState.sppStart = 0;\r\n        zoomState.maxWidth = 0;\r\n        zoomState.options = null;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/zoom.ts","import { Interval, Track } from 'waveshaper';\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\nimport { DomOptions } from '../config/dom-config';\r\n\r\ndeclare type SegmentSide = 'left' | 'right';\r\n\r\ninterface ResizeState {\r\n    activeSegment: Interval | null;\r\n    activeSegmentSide: SegmentSide | null;\r\n    activeSegmentOffsetStart: number;\r\n    activeSegmentOffsetEnd: number;\r\n    dragWave: Track | null;\r\n    options: DomOptions | null;\r\n}\r\n\r\nconst resizeState: ResizeState = {\r\n    activeSegment: null,\r\n    activeSegmentSide: null,\r\n    activeSegmentOffsetStart: 0,\r\n    activeSegmentOffsetEnd: 0,\r\n    dragWave: null,\r\n    options: null\r\n}\r\n\r\n/**\r\n * Adds drag functionality to waveshaper\r\n * \r\n * @param manager\r\n * @param hammer\r\n */\r\nexport default function(manager: DomRenderWaveShaper, hammer: HammerManager) {\r\n\r\n    const shouldHandle = (target: HTMLElement, options: DomOptions) => options.mode === 'resize' && target != null && target.hasAttribute('data-wave-id');\r\n\r\n    hammer.on('panstart', (ev) => { \r\n        const options = manager.options;\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(!shouldHandle(target, options))\r\n            return;\r\n\r\n        // Already checked that it exists\r\n        const id = <string>target.getAttribute('data-wave-id');\r\n\r\n        const wave = manager.getTrack(id);\r\n        if(wave == null) return;\r\n\r\n        const bb = target.getBoundingClientRect();\r\n        const time = ((options.scrollPosition + (ev.center.x - bb.left)) * options.samplesPerPixel) / options.samplerate;\r\n\r\n        const interval = wave.flattened.find(i => i.start + i.offsetStart <= time && i.end >= time);\r\n\r\n        if(interval == null) \r\n            return;\r\n\r\n        resizeState.activeSegmentSide = \r\n            time < interval.start + interval.offsetStart + ((interval.end - (interval.start + interval.offsetStart)) / 2) ? \r\n                'left' : \r\n                'right';\r\n\r\n        const segment = wave.intervals.find(s => s.id === interval.id);\r\n        if(segment == null) return;\r\n\r\n        resizeState.options = options;\r\n        resizeState.activeSegment = segment;\r\n\r\n        resizeState.activeSegmentOffsetStart = segment.offsetStart;\r\n        resizeState.activeSegmentOffsetEnd = segment.end;\r\n\r\n        segment.index = 1000;\r\n        resizeState.dragWave = wave;\r\n    });\r\n\r\n    hammer.on('panmove', (ev) =>  {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(resizeState.dragWave == null || resizeState.activeSegment == null || resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n\r\n        const options = manager.options;\r\n\r\n        const change = (ev.deltaX * options.samplesPerPixel) / options.samplerate;\r\n        let newTime = resizeState.activeSegmentSide === 'left' ?\r\n            resizeState.activeSegmentOffsetStart + change :\r\n            resizeState.activeSegmentOffsetEnd + change;\r\n\r\n        // Don't allow offset to become less than 0\r\n        if(newTime < 0) {\r\n            newTime = 0;\r\n        }\r\n\r\n        const active = resizeState.activeSegment;\r\n        const newDuration = resizeState.activeSegmentSide === 'left' ?\r\n            active.end - active.start - newTime :\r\n            newTime - active.start - active.offsetStart;\r\n\r\n        // Do not allow resizing \r\n        if(newDuration <= 2) {\r\n            return;\r\n        }\r\n        \r\n        resizeState.activeSegmentSide === 'left' ?\r\n            active.offsetStart = newTime :\r\n            active.end = newTime;\r\n\r\n        manager.flatten(resizeState.dragWave.id);\r\n        manager.process(resizeState.dragWave.id);\r\n    });\r\n\r\n    hammer.on('panend', (ev) => {\r\n        const target = manager.options.getEventTarget(ev.srcEvent);\r\n        if(resizeState.options == null || !shouldHandle(target, resizeState.options))\r\n            return;\r\n\r\n        resizeState.activeSegment = null;\r\n        resizeState.activeSegmentOffsetStart = 0;\r\n        resizeState.activeSegmentOffsetEnd = 0;\r\n        resizeState.activeSegmentSide = null;\r\n        resizeState.dragWave = null;\r\n        resizeState.options = null;\r\n    });\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/resize.ts","import { DomOptions } from \"../config/dom-config\";\r\n\r\n/**\r\n * \r\n * \r\n * @export\r\n * @param waveform Sampled data for each pixel, max at 0, min at 1 \r\n * @param options\r\n * @param ctx \r\n * @param color\r\n */\r\nexport default (waveform: Float32Array, options: DomOptions, ctx: CanvasRenderingContext2D, color: string) => {\r\n    const scale = options.height / 2;\r\n    const width = options.width;\r\n    \r\n    ctx.fillStyle = color;\r\n    ctx.clearRect(0, 0, width, options.height);\r\n    \r\n    for(let i = 0, inSegment = false, segmentStart = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        const pointInSegment = waveform[index + 3] === 1;\r\n        if(!inSegment && pointInSegment) {\r\n            inSegment = true;\r\n            segmentStart = i;\r\n        } else if (inSegment && (!pointInSegment || i === width - 1)) {\r\n            inSegment = false;\r\n            ctx.fillRect(segmentStart, 0, i - segmentStart, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fillStyle = 'black';\r\n    ctx.beginPath();\r\n    \r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n\r\n    ctx.moveTo(0, scale);\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n\r\n        ctx.lineTo(i, Math.round((waveform[index + 1] * scale) + scale));\r\n    }\r\n    ctx.lineTo(width - 1, scale);\r\n    ctx.closePath();\r\n\r\n    for (let i = 0; i < width; i++) {\r\n        const index = i * 4;\r\n        if(waveform[index - 4 + 2] === 0 && waveform[index + 2] === 1) {\r\n            ctx.rect(i, 0, 1, options.height);\r\n        }\r\n    }\r\n    \r\n    ctx.fill();\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/render/line.ts","import { DragState } from \"../models/dragstate\";\r\nimport DomRenderWaveShaper from '../core/domrender-waveshaper';\r\n\r\nexport default (manager: DomRenderWaveShaper,canvas: HTMLCanvasElement, dragState: DragState): () => void => {\r\n\r\n    const enterlistener = (ev: PointerEvent) => pointerEnter(ev);\r\n    const downlistener = (ev: PointerEvent) => canvas.releasePointerCapture(ev.pointerId);\r\n\r\n\r\n    /**\r\n     * Fires when the mouse moves over the container,\r\n     * If a segment is being dragged and the pointer moves\r\n     * into another canvas the segment is tranfered to the \r\n     * new canvas.\r\n     */\r\n    canvas.addEventListener('pointerenter', enterlistener);\r\n    canvas.addEventListener('pointerdown', downlistener);\r\n\r\n    const destroy = () => {\r\n        canvas.removeEventListener('pointerenter', enterlistener);\r\n        canvas.removeEventListener('pointerdown', downlistener);\r\n    }\r\n\r\n    const pointerEnter = (ev: PointerEvent) => {\r\n        if (dragState.options == null || dragState.options.mode !== 'drag' || dragState.activeSegment == null || dragState.dragWave == null)\r\n            return;\r\n\r\n        const canvas = dragState.options.getEventTarget(ev);\r\n        if (canvas == null || !(canvas instanceof HTMLCanvasElement))\r\n            return;\r\n\r\n        const id = canvas.getAttribute('data-wave-id');\r\n        if (id == null) return;\r\n\r\n        const wave = manager.getTrack(id);\r\n        if (wave == null) return;\r\n\r\n        if (dragState.dragWave.id !== id) {\r\n            const index = dragState.dragWave.intervals.indexOf(dragState.activeSegment);\r\n            dragState.dragWave.intervals.splice(index, 1);\r\n\r\n            wave.intervals.push(dragState.activeSegment);\r\n            dragState.activeSegment.index = 1000;\r\n\r\n            const currentId = dragState.dragWave.id;\r\n            dragState.dragWave = wave;\r\n\r\n            manager.flatten(wave.id, currentId);\r\n            manager.process(wave.id, currentId);\r\n        }\r\n    }\r\n\r\n    return destroy;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/interactions/enter.ts","import { defaultConfig, ManagerOptions, ManagerInput } from \"waveshaper\";\r\n\r\nexport type InteractionMode = 'pan' | 'drag' | 'cut' | 'resize';\r\nexport type GenerateId = () => string;\r\nexport type GetTarget = (ev: Event) => HTMLElement;\r\n\r\n\r\nexport interface DomOptions extends ManagerOptions {\r\n    getEventTarget: GetTarget;\r\n    registerSetsActive: boolean;\r\n    height: number;\r\n    generateId: GenerateId;\r\n    mode: InteractionMode;\r\n}\r\n\r\nexport interface DomInput extends ManagerInput {\r\n    getEventTarget?: GetTarget;\r\n    registerSetsActive?: boolean;\r\n    height?: number;\r\n    generateId?: GenerateId;\r\n    mode?: InteractionMode;\r\n}\r\n\r\nconst defaultDomOptions: DomOptions = {\r\n    ...defaultConfig,\r\n    mode: 'pan',\r\n    height: 150,\r\n    getEventTarget: (ev) => <HTMLElement>ev.target,\r\n    generateId: () => Math.random().toString(),\r\n    registerSetsActive: true \r\n}\r\n\r\nexport default defaultDomOptions;\n\n\n// WEBPACK FOOTER //\n// ./src/config/dom-config.ts","import { Interval, Track } from \"waveshaper\";\r\nimport { DomOptions } from \"../config/dom-config\";\r\n\r\nexport interface DragState {\r\n    activeSegment: Interval | null;\r\n    activeSegmentStart: number;\r\n    dragWave: Track | null;\r\n    options: DomOptions | null;\r\n    duration: number;\r\n    dragging: boolean;\r\n}\r\n\r\nexport const dragState: DragState = {\r\n    activeSegment: null,\r\n    activeSegmentStart: 0,\r\n    dragWave: null,\r\n    options: null,\r\n    duration: 0,\r\n    dragging: false\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/models/dragstate.ts"],"sourceRoot":""}